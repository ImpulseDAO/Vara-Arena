{"version":3,"file":"static/js/509.55670955.chunk.js","mappings":"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","sources":["../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js","../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs","../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../node_modules/@mantine/core/src/components/Button/ButtonGroup/ButtonGroup.tsx","../node_modules/@mantine/core/src/components/Button/Button.tsx","../node_modules/@mantine/core/src/components/Flex/flex-props.ts","../node_modules/@mantine/core/src/components/Flex/Flex.tsx","../node_modules/@mantine/core/src/components/Floating/FloatingArrow/get-arrow-position-styles.ts","../node_modules/@mantine/core/src/components/Floating/FloatingArrow/FloatingArrow.tsx","../node_modules/@mantine/core/src/components/Floating/get-floating-position/get-floating-position.ts","../node_modules/@mantine/core/src/components/Floating/use-floating-auto-update.ts","../node_modules/@mantine/core/src/components/Portal/Portal.tsx","../node_modules/@mantine/core/src/components/Portal/OptionalPortal.tsx","../node_modules/@mantine/core/src/components/Stack/Stack.tsx","../node_modules/@mantine/core/src/components/Text/Text.tsx","../node_modules/@mantine/core/src/components/UnstyledButton/UnstyledButton.tsx","../node_modules/@mantine/core/src/core/DirectionProvider/DirectionProvider.tsx","../node_modules/@mantine/core/src/core/utils/is-element/is-element.ts","../node_modules/@mantine/hooks/src/use-id/use-react-id.ts","../node_modules/@mantine/hooks/src/use-id/use-id.ts","../node_modules/@mantine/hooks/src/use-merged-ref/use-merged-ref.ts","../node_modules/@mantine/hooks/src/utils/random-id/random-id.ts"],"sourcesContent":["import { platform, getOverflowAncestors, useFloating as useFloating$1, offset, detectOverflow } from '@floating-ui/react-dom';\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/react-dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect, useRef } from 'react';\nimport { supportsInert, hideOthers, suppressOthers } from 'aria-hidden';\nimport { tabbable } from 'tabbable';\nimport { createPortal, flushSync } from 'react-dom';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => \"floating-ui-\" + count++;\nfunction useFloatingId() {\n  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  React.useEffect(() => {\n    if (!serverHandoffComplete) {\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id;\n}\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = React[/*#__PURE__*/'useId'.toString()];\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/useId\n */\nconst useId = useReactId || useFloatingId;\n\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */\nconst FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(_ref, ref) {\n  let {\n    context: {\n      placement,\n      elements: {\n        floating\n      },\n      middlewareData: {\n        arrow\n      }\n    },\n    width = 14,\n    height = 7,\n    tipRadius = 0,\n    strokeWidth = 0,\n    staticOffset,\n    stroke,\n    d,\n    style: {\n      transform,\n      ...restStyle\n    } = {},\n    ...rest\n  } = _ref;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!ref) {\n      console.warn('Floating UI: The `ref` prop is required for the `FloatingArrow`', 'component.');\n    }\n  }\n  const clipPathId = useId();\n  if (!floating) {\n    return null;\n  }\n\n  // Strokes must be double the border width, this ensures the stroke's width\n  // works as you'd expect.\n  strokeWidth *= 2;\n  const halfStrokeWidth = strokeWidth / 2;\n  const svgX = width / 2 * (tipRadius / -8 + 1);\n  const svgY = height / 2 * tipRadius / 4;\n  const [side, alignment] = placement.split('-');\n  const isRTL = platform.isRTL(floating);\n  const isCustomShape = !!d;\n  const isVerticalSide = side === 'top' || side === 'bottom';\n  const yOffsetProp = staticOffset && alignment === 'end' ? 'bottom' : 'top';\n  let xOffsetProp = staticOffset && alignment === 'end' ? 'right' : 'left';\n  if (staticOffset && isRTL) {\n    xOffsetProp = alignment === 'end' ? 'left' : 'right';\n  }\n  const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';\n  const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : '';\n  const dValue = d || 'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n  const rotation = {\n    top: isCustomShape ? 'rotate(180deg)' : '',\n    left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n    bottom: isCustomShape ? '' : 'rotate(180deg)',\n    right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n  }[side];\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({}, rest, {\n    \"aria-hidden\": true,\n    ref: ref,\n    width: isCustomShape ? width : width + strokeWidth,\n    height: width,\n    viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n    style: {\n      position: 'absolute',\n      pointerEvents: 'none',\n      [xOffsetProp]: arrowX,\n      [yOffsetProp]: arrowY,\n      [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + strokeWidth / 2 + \"px)\",\n      transform: \"\" + rotation + (transform != null ? transform : ''),\n      ...restStyle\n    }\n  }), strokeWidth > 0 && /*#__PURE__*/React.createElement(\"path\", {\n    clipPath: \"url(#\" + clipPathId + \")\",\n    fill: \"none\",\n    stroke: stroke\n    // Account for the stroke on the fill path rendered below.\n    ,\n    strokeWidth: strokeWidth + (d ? 0 : 1),\n    d: dValue\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    stroke: strokeWidth && !d ? rest.fill : 'none',\n    d: dValue\n  }), /*#__PURE__*/React.createElement(\"clipPath\", {\n    id: clipPathId\n  }, /*#__PURE__*/React.createElement(\"rect\", {\n    x: -halfStrokeWidth,\n    y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n    width: width + strokeWidth,\n    height: width\n  })));\n});\n\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach(handler => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n    off(event, listener) {\n      var _map$get2;\n      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);\n    }\n  };\n}\n\nconst FloatingNodeContext = /*#__PURE__*/React.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/React.createContext(null);\nconst useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\nconst useFloatingTree = () => React.useContext(FloatingTreeContext);\n\n/**\n * Registers a node into the floating tree, returning its id.\n */\nfunction useFloatingNodeId(customParentId) {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null ? void 0 : tree.addNode(node);\n    return () => {\n      tree == null ? void 0 : tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n}\n\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingNode(_ref) {\n  let {\n    children,\n    id\n  } = _ref;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/React.createElement(FloatingNodeContext.Provider, {\n    value: React.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n}\n\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM (i.e. portalled to a common node, rather than their\n * respective parent).\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingTree(_ref2) {\n  let {\n    children\n  } = _ref2;\n  const nodesRef = React.useRef([]);\n  const addNode = React.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = React.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = React.useState(() => createPubSub())[0];\n  return /*#__PURE__*/React.createElement(FloatingTreeContext.Provider, {\n    value: React.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [nodesRef, addNode, removeNode, events])\n  }, children);\n}\n\nfunction getDocument(node) {\n  return (node == null ? void 0 : node.ownerDocument) || document;\n}\n\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\n\nfunction getWindow(value) {\n  return getDocument(value).defaultView || window;\n}\nfunction isElement(value) {\n  return value ? value instanceof Element || value instanceof getWindow(value).Element : false;\n}\nfunction isHTMLElement(value) {\n  return value ? value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement : false;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  const androidRe = /Android/i;\n  if ((androidRe.test(getPlatform()) || androidRe.test(getUserAgent())) && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType !== 'mouse' ||\n  // iOS VoiceOver returns 0.333 for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n  // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n  // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n  const values = ['mouse', 'pen'];\n  if (!strict) {\n    values.push('', undefined);\n  }\n  return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n  return 'nativeEvent' in event;\n}\n\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode && child.getRootNode();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      // @ts-ignore\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\n\nfunction createAttribute(name) {\n  return \"data-floating-ui-\" + name;\n}\n\nfunction useLatestRef(value) {\n  const ref = useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\nconst safePolygonIdentifier = /*#__PURE__*/createAttribute('safe-polygon');\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !isMouseLikePointerType(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */\nfunction useHover(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    elements: {\n      domReference,\n      floating\n    },\n    refs\n  } = context;\n  const {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = props;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const pointerTypeRef = React.useRef();\n  const timeoutRef = React.useRef();\n  const handlerRef = React.useRef();\n  const restTimeoutRef = React.useRef();\n  const blockMouseMoveRef = React.useRef(true);\n  const performedPointerEventsMutationRef = React.useRef(false);\n  const unbindMouseMoveRef = React.useRef(() => {});\n  const isHoverOpen = React.useCallback(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]);\n\n  // When dismissing before opening, clear the delay timeouts to cancel it\n  // from showing.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onDismiss() {\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      blockMouseMoveRef.current = true;\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [enabled, events]);\n  React.useEffect(() => {\n    if (!enabled || !handleCloseRef.current || !open) {\n      return;\n    }\n    function onLeave(event) {\n      if (isHoverOpen()) {\n        onOpenChange(false, event);\n      }\n    }\n    const html = getDocument(floating).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [floating, open, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);\n  const closeWithDelay = React.useCallback(function (event, runElseBranch) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => onOpenChange(false, event), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false, event);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = React.useCallback(() => {\n    unbindMouseMoveRef.current();\n    handlerRef.current = undefined;\n  }, []);\n  const clearPointerEvents = React.useCallback(() => {\n    if (performedPointerEventsMutationRef.current) {\n      const body = getDocument(refs.floating.current).body;\n      body.style.pointerEvents = '';\n      body.removeAttribute(safePolygonIdentifier);\n      performedPointerEventsMutationRef.current = false;\n    }\n  }, [refs]);\n\n  // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function isClickLikeOpenEvent() {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    }\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {\n        return;\n      }\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = setTimeout(() => {\n          onOpenChange(true, event);\n        }, openDelay);\n      } else {\n        onOpenChange(true, event);\n      }\n    }\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      unbindMouseMoveRef.current();\n      const doc = getDocument(floating);\n      clearTimeout(restTimeoutRef.current);\n      if (handleCloseRef.current) {\n        // Prevent clearing `onScrollMouseLeave` timeout.\n        if (!open) {\n          clearTimeout(timeoutRef.current);\n        }\n        handlerRef.current = handleCloseRef.current({\n          ...context,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            // Should the event expose that it was closed by `safePolygon`?\n            closeWithDelay(event);\n          }\n        });\n        const handler = handlerRef.current;\n        doc.addEventListener('mousemove', handler);\n        unbindMouseMoveRef.current = () => {\n          doc.removeEventListener('mousemove', handler);\n        };\n        return;\n      }\n\n      // Allow interactivity without `safePolygon` on touch devices. With a\n      // pointer, a short close delay is an alternative, so it should work\n      // consistently.\n      const shouldClose = pointerTypeRef.current === 'touch' ? !contains(floating, event.relatedTarget) : true;\n      if (shouldClose) {\n        closeWithDelay(event);\n      }\n    }\n\n    // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      handleCloseRef.current == null ? void 0 : handleCloseRef.current({\n        ...context,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          closeWithDelay(event);\n        }\n      })(event);\n    }\n    if (isElement(domReference)) {\n      const ref = domReference;\n      open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null ? void 0 : floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && ref.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      ref.addEventListener('mouseenter', onMouseEnter);\n      ref.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null ? void 0 : floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.removeEventListener('mousemove', onMouseEnter);\n        ref.removeEventListener('mouseenter', onMouseEnter);\n        ref.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);\n\n  // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n  index(() => {\n    var _handleCloseRef$curre;\n    if (!enabled) {\n      return;\n    }\n    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n      const body = getDocument(floating).body;\n      body.setAttribute(safePolygonIdentifier, '');\n      body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      if (isElement(domReference) && floating) {\n        var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n        const ref = domReference;\n        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        ref.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          ref.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, dataRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      cleanupMouseMoveHandler();\n      clearPointerEvents();\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n  React.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      clearPointerEvents();\n    };\n  }, [enabled, cleanupMouseMoveHandler, clearPointerEvents]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n        onMouseMove(event) {\n          if (open || restMs === 0) {\n            return;\n          }\n          clearTimeout(restTimeoutRef.current);\n          restTimeoutRef.current = setTimeout(() => {\n            if (!blockMouseMoveRef.current) {\n              onOpenChange(true, event.nativeEvent);\n            }\n          }, restMs);\n        }\n      },\n      floating: {\n        onMouseEnter() {\n          clearTimeout(timeoutRef.current);\n        },\n        onMouseLeave(event) {\n          events.emit('dismiss', {\n            type: 'mouseLeave',\n            data: {\n              returnFocus: false\n            }\n          });\n          closeWithDelay(event.nativeEvent, false);\n        }\n      }\n    };\n  }, [events, enabled, restMs, open, onOpenChange, closeWithDelay]);\n}\n\nconst FloatingDelayGroupContext = /*#__PURE__*/React.createContext({\n  delay: 0,\n  initialDelay: 0,\n  timeoutMs: 0,\n  currentId: null,\n  setCurrentId: () => {},\n  setState: () => {},\n  isInstantPhase: false\n});\nconst useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nconst FloatingDelayGroup = _ref => {\n  let {\n    children,\n    delay,\n    timeoutMs = 0\n  } = _ref;\n  const [state, setState] = React.useReducer((prev, next) => ({\n    ...prev,\n    ...next\n  }), {\n    delay,\n    timeoutMs,\n    initialDelay: delay,\n    currentId: null,\n    isInstantPhase: false\n  });\n  const initialCurrentIdRef = React.useRef(null);\n  const setCurrentId = React.useCallback(currentId => {\n    setState({\n      currentId\n    });\n  }, []);\n  index(() => {\n    if (state.currentId) {\n      if (initialCurrentIdRef.current === null) {\n        initialCurrentIdRef.current = state.currentId;\n      } else {\n        setState({\n          isInstantPhase: true\n        });\n      }\n    } else {\n      setState({\n        isInstantPhase: false\n      });\n      initialCurrentIdRef.current = null;\n    }\n  }, [state.currentId]);\n  return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {\n    value: React.useMemo(() => ({\n      ...state,\n      setState,\n      setCurrentId\n    }), [state, setState, setCurrentId])\n  }, children);\n};\nconst useDelayGroup = (_ref2, _ref3) => {\n  let {\n    open,\n    onOpenChange\n  } = _ref2;\n  let {\n    id\n  } = _ref3;\n  const {\n    currentId,\n    setCurrentId,\n    initialDelay,\n    setState,\n    timeoutMs\n  } = useDelayGroupContext();\n  index(() => {\n    if (currentId) {\n      setState({\n        delay: {\n          open: 1,\n          close: getDelay(initialDelay, 'close')\n        }\n      });\n      if (currentId !== id) {\n        onOpenChange(false);\n      }\n    }\n  }, [id, onOpenChange, setState, currentId, initialDelay]);\n  index(() => {\n    function unset() {\n      onOpenChange(false);\n      setState({\n        delay: initialDelay,\n        currentId: null\n      });\n    }\n    if (!open && currentId === id) {\n      if (timeoutMs) {\n        const timeout = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeout);\n        };\n      } else {\n        unset();\n      }\n    }\n  }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n  index(() => {\n    if (open) {\n      setCurrentId(id);\n    }\n  }, [open, setCurrentId, id]);\n};\n\n/**\n * Find the real active element. Traverses into shadowRoots.\n */\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n  while (((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {\n    var _activeElement, _activeElement$shadow;\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\n\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\n\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\n\nfunction getChildren(nodes, id) {\n  let allChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  });\n  let currentChildren = allChildren;\n  while (currentChildren.length) {\n    currentChildren = nodes.filter(node => {\n      var _currentChildren;\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    });\n    allChildren = allChildren.concat(currentChildren);\n  }\n  return allChildren;\n}\n\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\n\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\n\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = tabbable(container, getTabbableOptions());\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = tabbable(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    event.target;\n    clearTimeout(timeoutId);\n  }\n}\nconst FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref) {\n  const [role, setRole] = React.useState();\n  index(() => {\n    if (isSafari()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  const restProps = {\n    ref,\n    tabIndex: 0,\n    // Role is only for VoiceOver\n    role,\n    'aria-hidden': role ? undefined : true,\n    [createAttribute('focus-guard')]: '',\n    style: HIDDEN_STYLES\n  };\n  return /*#__PURE__*/React.createElement(\"span\", _extends({}, props, restProps));\n});\n\nconst PortalContext = /*#__PURE__*/React.createContext(null);\nfunction useFloatingPortalNode(_temp) {\n  let {\n    id,\n    root\n  } = _temp === void 0 ? {} : _temp;\n  const [portalNode, setPortalNode] = React.useState(null);\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  const data = React.useMemo(() => ({\n    id,\n    root,\n    portalContext,\n    uniqueId\n  }), [id, root, portalContext, uniqueId]);\n  const dataRef = React.useRef();\n  index(() => {\n    return () => {\n      portalNode == null ? void 0 : portalNode.remove();\n    };\n  }, [portalNode, data]);\n  index(() => {\n    if (dataRef.current === data) return;\n    dataRef.current = data;\n    const {\n      id,\n      root,\n      portalContext,\n      uniqueId\n    } = data;\n    const existingIdRoot = id ? document.getElementById(id) : null;\n    const attr = createAttribute('portal');\n    if (existingIdRoot) {\n      const subRoot = document.createElement('div');\n      subRoot.id = uniqueId;\n      subRoot.setAttribute(attr, '');\n      existingIdRoot.appendChild(subRoot);\n      setPortalNode(subRoot);\n    } else {\n      let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n      if (container && !isElement(container)) container = container.current;\n      container = container || document.body;\n      let idWrapper = null;\n      if (id) {\n        idWrapper = document.createElement('div');\n        idWrapper.id = id;\n        container.appendChild(idWrapper);\n      }\n      const subRoot = document.createElement('div');\n      subRoot.id = uniqueId;\n      subRoot.setAttribute(attr, '');\n      container = idWrapper || container;\n      container.appendChild(subRoot);\n      setPortalNode(subRoot);\n    }\n  }, [data]);\n  return portalNode;\n}\n/**\n * Portals the floating element into a given container element  by default,\n * outside of the app root and into the body.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\nfunction FloatingPortal(_ref) {\n  let {\n    children,\n    id,\n    root = null,\n    preserveTabOrder = true\n  } = _ref;\n  const portalNode = useFloatingPortalNode({\n    id,\n    root\n  });\n  const [focusManagerState, setFocusManagerState] = React.useState(null);\n  const beforeOutsideRef = React.useRef(null);\n  const afterOutsideRef = React.useRef(null);\n  const beforeInsideRef = React.useRef(null);\n  const afterInsideRef = React.useRef(null);\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal &&\n  // Don't render if unmount is transitioning.\n  focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n  React.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n      return;\n    }\n\n    // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    }\n    // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n  return /*#__PURE__*/React.createElement(PortalContext.Provider, {\n    value: React.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null ? void 0 : prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), portalNode && /*#__PURE__*/createPortal(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n        (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null ? void 0 : nextTabbable.focus();\n        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n      }\n    }\n  }));\n}\nconst usePortalContext = () => React.useContext(PortalContext);\n\nconst VisuallyHiddenDismiss = /*#__PURE__*/React.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/React.createElement(\"button\", _extends({}, props, {\n    type: \"button\",\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(props) {\n  const {\n    context,\n    children,\n    disabled = false,\n    order = ['content'],\n    guards: _guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true,\n    visuallyHiddenDismiss = false,\n    closeOnFocusOut = true\n  } = props;\n  const {\n    open,\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n\n  // Force the guards to be rendered if the `inert` attribute is not supported.\n  const guards = supportsInert() ? _guards : true;\n  const orderRef = useLatestRef(order);\n  const initialFocusRef = useLatestRef(initialFocus);\n  const returnFocusRef = useLatestRef(returnFocus);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n\n  // Controlled by `useListNavigation`.\n  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n  const startDismissButtonRef = React.useRef(null);\n  const endDismissButtonRef = React.useRef(null);\n  const preventReturnFocusRef = React.useRef(false);\n  const previouslyFocusedElementRef = React.useRef(null);\n  const isPointerDownRef = React.useRef(false);\n  const isInsidePortal = portalContext != null;\n\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isTypeableCombobox = domReference && domReference.getAttribute('role') === 'combobox' && isTypeableElement(domReference);\n  const getTabbableContent = React.useCallback(function (container) {\n    if (container === void 0) {\n      container = floating;\n    }\n    return container ? tabbable(container, getTabbableOptions()) : [];\n  }, [floating]);\n  const getTabbableElements = React.useCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (domReference && type === 'reference') {\n        return domReference;\n      }\n      if (floating && type === 'floating') {\n        return floating;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  }, [domReference, floating, orderRef, getTabbableContent]);\n  React.useEffect(() => {\n    if (disabled || !modal) return;\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if (contains(floating, activeElement(getDocument(floating))) && getTabbableContent().length === 0 && !isTypeableCombobox) {\n          stopEvent(event);\n        }\n        const els = getTabbableElements();\n        const target = getTarget(event);\n        if (orderRef.current[0] === 'reference' && target === domReference) {\n          stopEvent(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === floating && event.shiftKey) {\n          stopEvent(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = getDocument(floating);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [disabled, domReference, floating, modal, orderRef, refs, isTypeableCombobox, getTabbableContent, getTabbableElements]);\n  React.useEffect(() => {\n    if (disabled || !closeOnFocusOut) return;\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      setTimeout(() => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      queueMicrotask(() => {\n        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute('focus-guard')) || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context, _node$context2;\n          return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n        }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context3, _node$context4;\n          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n        })));\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        relatedTarget !== previouslyFocusedElementRef.current) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false, event);\n        }\n      });\n    }\n    if (floating && isHTMLElement(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      !modal && floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        !modal && floating.removeEventListener('focusout', handleFocusOutside);\n      };\n    }\n  }, [disabled, domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);\n  React.useEffect(() => {\n    var _portalContext$portal;\n    if (disabled) return;\n\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from((portalContext == null ? void 0 : (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute('portal') + \"]\")) || []);\n    if (floating && modal) {\n      const insideNodes = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current].filter(x => x != null);\n      const suppressorFn = guards ? hideOthers : suppressOthers;\n      const cleanup = suppressorFn(orderRef.current.includes('reference') || isTypeableCombobox ? insideNodes.concat(domReference || []) : insideNodes, undefined, createAttribute('inert'));\n      return () => {\n        cleanup();\n      };\n    }\n  }, [disabled, domReference, floating, modal, orderRef, portalContext, isTypeableCombobox, guards]);\n  index(() => {\n    if (disabled || !floating) return;\n    const doc = getDocument(floating);\n    const previouslyFocusedElement = activeElement(doc);\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floating);\n      const initialFocusValue = initialFocusRef.current;\n      const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n      const focusAlreadyInsideFloatingEl = contains(floating, previouslyFocusedElement);\n      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floating\n        });\n      }\n    });\n  }, [disabled, open, floating, ignoreInitialFocus, getTabbableElements, initialFocusRef]);\n  index(() => {\n    if (disabled || !floating) return;\n    let preventReturnFocusScroll = false;\n    const doc = getDocument(floating);\n    const previouslyFocusedElement = activeElement(doc);\n    const contextData = dataRef.current;\n    previouslyFocusedElementRef.current = previouslyFocusedElement;\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onDismiss(payload) {\n      if (payload.type === 'escapeKey' && refs.domReference.current) {\n        previouslyFocusedElementRef.current = refs.domReference.current;\n      }\n      if (['referencePress', 'escapeKey'].includes(payload.type)) {\n        return;\n      }\n      const returnFocus = payload.data.returnFocus;\n      if (typeof returnFocus === 'object') {\n        preventReturnFocusRef.current = false;\n        preventReturnFocusScroll = returnFocus.preventScroll;\n      } else {\n        preventReturnFocusRef.current = !returnFocus;\n      }\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n      const activeEl = activeElement(doc);\n      const shouldFocusReference = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context5;\n        return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n      }) || contextData.openEvent && ['click', 'mousedown'].includes(contextData.openEvent.type);\n      if (shouldFocusReference && refs.domReference.current) {\n        previouslyFocusedElementRef.current = refs.domReference.current;\n      }\n      if (\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      returnFocusRef.current && isHTMLElement(previouslyFocusedElementRef.current) && !preventReturnFocusRef.current) {\n        enqueueFocus(previouslyFocusedElementRef.current, {\n          // When dismissing nested floating elements, by the time the rAF has\n          // executed, the menus will all have been unmounted. When they try\n          // to get focused, the calls get ignored  leaving the root\n          // reference focused as desired.\n          cancelPrevious: false,\n          preventScroll: preventReturnFocusScroll\n        });\n      }\n    };\n  }, [disabled, floating, returnFocusRef, dataRef, refs, events, tree, nodeId]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  index(() => {\n    if (disabled || !portalContext) return;\n    portalContext.setFocusManagerState({\n      ...context,\n      modal,\n      closeOnFocusOut,\n      open\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [disabled, portalContext, modal, open, closeOnFocusOut, context]);\n  index(() => {\n    if (disabled) return;\n    if (floating && typeof MutationObserver === 'function') {\n      const handleMutation = () => {\n        const tabIndex = floating.getAttribute('tabindex');\n        if (orderRef.current.includes('floating') || activeElement(getDocument(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n          if (tabIndex !== '0') {\n            floating.setAttribute('tabindex', '0');\n          }\n        } else if (tabIndex !== '-1') {\n          floating.setAttribute('tabindex', '-1');\n        }\n      };\n      handleMutation();\n      const observer = new MutationObserver(handleMutation);\n      observer.observe(floating, {\n        childList: true,\n        subtree: true,\n        attributes: true\n      });\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [disabled, floating, refs, orderRef, getTabbableContent]);\n  function renderDismissButton(location) {\n    if (disabled || !visuallyHiddenDismiss || !modal) {\n      return null;\n    }\n    return /*#__PURE__*/React.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: event => onOpenChange(false, event.nativeEvent)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss');\n  }\n  const shouldRenderGuards = !disabled && guards && !isTypeableCombobox && (isInsidePortal || modal);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null ? void 0 : nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null ? void 0 : _portalContext$before.focus();\n        }\n      }\n    }\n  }), !isTypeableCombobox && renderDismissButton('start'), children, renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        if (closeOnFocusOut) {\n          preventReturnFocusRef.current = true;\n        }\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null ? void 0 : prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null ? void 0 : _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\n\nfunction sortByDocumentPosition(a, b) {\n  const position = a.compareDocumentPosition(b);\n  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    return -1;\n  }\n  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n    return 1;\n  }\n  return 0;\n}\nfunction areMapsEqual(map1, map2) {\n  if (map1.size !== map2.size) {\n    return false;\n  }\n  for (const [key, value] of map1.entries()) {\n    if (value !== map2.get(key)) {\n      return false;\n    }\n  }\n  return true;\n}\nconst FloatingListContext = /*#__PURE__*/React.createContext({\n  register: () => {},\n  unregister: () => {},\n  map: /*#__PURE__*/new Map(),\n  elementsRef: {\n    current: []\n  }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */\nfunction FloatingList(_ref) {\n  let {\n    children,\n    elementsRef,\n    labelsRef\n  } = _ref;\n  const [map, setMap] = React.useState(() => new Map());\n  const register = React.useCallback(node => {\n    setMap(prevMap => new Map(prevMap).set(node, null));\n  }, []);\n  const unregister = React.useCallback(node => {\n    setMap(prevMap => {\n      const map = new Map(prevMap);\n      map.delete(node);\n      return map;\n    });\n  }, []);\n  index(() => {\n    const newMap = new Map(map);\n    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n    nodes.forEach((node, index) => {\n      newMap.set(node, index);\n    });\n    if (!areMapsEqual(map, newMap)) {\n      setMap(newMap);\n    }\n  }, [map]);\n  return /*#__PURE__*/React.createElement(FloatingListContext.Provider, {\n    value: React.useMemo(() => ({\n      register,\n      unregister,\n      map,\n      elementsRef,\n      labelsRef\n    }), [register, unregister, map, elementsRef, labelsRef])\n  }, children);\n}\nfunction useListItem(_temp) {\n  let {\n    label\n  } = _temp === void 0 ? {} : _temp;\n  const [index$1, setIndex] = React.useState(null);\n  const componentRef = React.useRef(null);\n  const {\n    register,\n    unregister,\n    map,\n    elementsRef,\n    labelsRef\n  } = React.useContext(FloatingListContext);\n  const ref = React.useCallback(node => {\n    componentRef.current = node;\n    if (index$1 !== null) {\n      elementsRef.current[index$1] = node;\n      if (labelsRef) {\n        var _node$textContent;\n        const isLabelDefined = label !== undefined;\n        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n      }\n    }\n  }, [index$1, elementsRef, labelsRef, label]);\n  index(() => {\n    const node = componentRef.current;\n    if (node) {\n      register(node);\n      return () => {\n        unregister(node);\n      };\n    }\n  }, [register, unregister]);\n  index(() => {\n    const index = componentRef.current ? map.get(componentRef.current) : null;\n    if (index != null) {\n      setIndex(index);\n    }\n  }, [map]);\n  return React.useMemo(() => ({\n    ref,\n    index: index$1 == null ? -1 : index$1\n  }), [index$1, ref]);\n}\n\nconst identifier = /*#__PURE__*/createAttribute('scroll-lock');\n\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\nconst FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(_ref, ref) {\n  let {\n    lockScroll = false,\n    ...rest\n  } = _ref;\n  index(() => {\n    var _window$visualViewpor, _window$visualViewpor2;\n    if (!lockScroll) {\n      return;\n    }\n    const alreadyLocked = document.body.hasAttribute(identifier);\n    if (alreadyLocked) {\n      return;\n    }\n    document.body.setAttribute(identifier, '');\n\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {\n      Object.assign(document.body.style, {\n        overflow: 'hidden',\n        [paddingProp]: scrollbarWidth + \"px\"\n      });\n      return () => {\n        document.body.removeAttribute(identifier);\n        Object.assign(document.body.style, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n      };\n    }\n\n    // iOS 12 does not support `visualViewport`.\n    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n    const scrollX = window.pageXOffset;\n    const scrollY = window.pageYOffset;\n    Object.assign(document.body.style, {\n      position: 'fixed',\n      overflow: 'hidden',\n      top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n      left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n      right: '0',\n      [paddingProp]: scrollbarWidth + \"px\"\n    });\n    return () => {\n      Object.assign(document.body.style, {\n        position: '',\n        overflow: '',\n        top: '',\n        left: '',\n        right: '',\n        [paddingProp]: ''\n      });\n      document.body.removeAttribute(identifier);\n      window.scrollTo(scrollX, scrollY);\n    };\n  }, [lockScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  }));\n});\n\nfunction isButtonTarget(event) {\n  return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isSpaceIgnored(element) {\n  return isTypeableElement(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */\nfunction useClick(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true\n  } = props;\n  const pointerTypeRef = React.useRef();\n  const didKeyDownRef = React.useRef(false);\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    return {\n      reference: {\n        onPointerDown(event) {\n          pointerTypeRef.current = event.pointerType;\n        },\n        onMouseDown(event) {\n          // Ignore all buttons except for the \"main\" button.\n          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n          if (event.button !== 0) {\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (eventOption === 'click') {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n            onOpenChange(false, event.nativeEvent);\n          } else {\n            // Prevent stealing focus from the floating element\n            event.preventDefault();\n            onOpenChange(true, event.nativeEvent);\n          }\n        },\n        onClick(event) {\n          if (eventOption === 'mousedown' && pointerTypeRef.current) {\n            pointerTypeRef.current = undefined;\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n            onOpenChange(false, event.nativeEvent);\n          } else {\n            onOpenChange(true, event.nativeEvent);\n          }\n        },\n        onKeyDown(event) {\n          pointerTypeRef.current = undefined;\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n            return;\n          }\n          if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n            // Prevent scrolling\n            event.preventDefault();\n            didKeyDownRef.current = true;\n          }\n          if (event.key === 'Enter') {\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent);\n            } else {\n              onOpenChange(true, event.nativeEvent);\n            }\n          }\n        },\n        onKeyUp(event) {\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n            return;\n          }\n          if (event.key === ' ' && didKeyDownRef.current) {\n            didKeyDownRef.current = false;\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent);\n            } else {\n              onOpenChange(true, event.nativeEvent);\n            }\n          }\n        }\n      }\n    };\n  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);\n}\n\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = React[/*#__PURE__*/'useInsertionEffect'.toString()];\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEffectEvent(callback) {\n  const ref = React.useRef(() => {\n    if (process.env.NODE_ENV !== \"production\") {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\n\nfunction createVirtualElement(domRef, data) {\n  let offsetX = null;\n  let offsetY = null;\n  let isAutoUpdateEvent = false;\n  return {\n    contextElement: domRef.current || undefined,\n    getBoundingClientRect() {\n      var _domRef$current, _data$dataRef$current;\n      const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      const isXAxis = data.axis === 'x' || data.axis === 'both';\n      const isYAxis = data.axis === 'y' || data.axis === 'both';\n      const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n      let width = domRect.width;\n      let height = domRect.height;\n      let x = domRect.x;\n      let y = domRect.y;\n      if (offsetX == null && data.x && isXAxis) {\n        offsetX = domRect.x - data.x;\n      }\n      if (offsetY == null && data.y && isYAxis) {\n        offsetY = domRect.y - data.y;\n      }\n      x -= offsetX || 0;\n      y -= offsetY || 0;\n      width = 0;\n      height = 0;\n      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n        width = data.axis === 'y' ? domRect.width : 0;\n        height = data.axis === 'x' ? domRect.height : 0;\n        x = isXAxis && data.x != null ? data.x : x;\n        y = isYAxis && data.y != null ? data.y : y;\n      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n        height = data.axis === 'x' ? domRect.height : height;\n        width = data.axis === 'y' ? domRect.width : width;\n      }\n      isAutoUpdateEvent = true;\n      return {\n        width,\n        height,\n        x,\n        y,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x\n      };\n    }\n  };\n}\nfunction isMouseBasedEvent(event) {\n  return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */\nfunction useClientPoint(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    refs,\n    dataRef,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    enabled = true,\n    axis = 'both',\n    x = null,\n    y = null\n  } = props;\n  const initialRef = React.useRef(false);\n  const cleanupListenerRef = React.useRef(null);\n  const [pointerType, setPointerType] = React.useState();\n  const [reactive, setReactive] = React.useState([]);\n  const setReference = useEffectEvent((x, y) => {\n    if (initialRef.current) return;\n\n    // Prevent setting if the open event was not a mouse-like one\n    // (e.g. focus to open, then hover over the reference element).\n    // Only apply if the event exists.\n    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n      return;\n    }\n    refs.setPositionReference(createVirtualElement(refs.domReference, {\n      x,\n      y,\n      axis,\n      dataRef,\n      pointerType\n    }));\n  });\n  const handleReferenceEnterOrMove = useEffectEvent(event => {\n    if (x != null || y != null) return;\n    if (!open) {\n      setReference(event.clientX, event.clientY);\n    } else if (!cleanupListenerRef.current) {\n      // If there's no cleanup, there's no listener, but we want to ensure\n      // we add the listener if the cursor landed on the floating element and\n      // then back on the reference (i.e. it's interactive).\n      setReactive([]);\n    }\n  });\n\n  // If the pointer is a mouse-like pointer, we want to continue following the\n  // mouse even if the floating element is transitioning out. On touch\n  // devices, this is undesirable because the floating element will move to\n  // the dismissal touch point.\n  const openCheck = isMouseLikePointerType(pointerType) ? floating : open;\n  const addListener = React.useCallback(() => {\n    // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n    if (!openCheck || !enabled || x != null || y != null) return;\n    const win = getWindow(refs.floating.current);\n    function handleMouseMove(event) {\n      const target = getTarget(event);\n      if (!contains(refs.floating.current, target)) {\n        setReference(event.clientX, event.clientY);\n      } else {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      }\n    }\n    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n      win.addEventListener('mousemove', handleMouseMove);\n      const cleanup = () => {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      };\n      cleanupListenerRef.current = cleanup;\n      return cleanup;\n    }\n    refs.setPositionReference(refs.domReference.current);\n  }, [dataRef, enabled, openCheck, refs, setReference, x, y]);\n  React.useEffect(() => {\n    return addListener();\n  }, [addListener, reactive]);\n  React.useEffect(() => {\n    if (enabled && !floating) {\n      initialRef.current = false;\n    }\n  }, [enabled, floating]);\n  React.useEffect(() => {\n    if (!enabled && open) {\n      initialRef.current = true;\n    }\n  }, [enabled, open]);\n  index(() => {\n    if (enabled && (x != null || y != null)) {\n      initialRef.current = false;\n      setReference(x, y);\n    }\n  }, [enabled, x, y, setReference]);\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    function setPointerTypeRef(_ref) {\n      let {\n        pointerType\n      } = _ref;\n      setPointerType(pointerType);\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerTypeRef,\n        onPointerEnter: setPointerTypeRef,\n        onMouseMove: handleReferenceEnterOrMove,\n        onMouseEnter: handleReferenceEnterOrMove\n      }\n    };\n  }, [enabled, handleReferenceEnterOrMove]);\n}\n\n/**\n * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.\n *\n * @param event The event whose target/composedPath to check\n * @param node The node to check against\n * @returns Whether the event.target/composedPath is within the node.\n */\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\n\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\nconst normalizeBubblesProp = bubbles => {\n  var _bubbles$escapeKey, _bubbles$outsidePress;\n  return {\n    escapeKeyBubbles: typeof bubbles === 'boolean' ? bubbles : (_bubbles$escapeKey = bubbles == null ? void 0 : bubbles.escapeKey) != null ? _bubbles$escapeKey : false,\n    outsidePressBubbles: typeof bubbles === 'boolean' ? bubbles : (_bubbles$outsidePress = bubbles == null ? void 0 : bubbles.outsidePress) != null ? _bubbles$outsidePress : true\n  };\n};\n/**\n * Closes the floating element when a dismissal is requested  by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nfunction useDismiss(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    events,\n    nodeId,\n    elements: {\n      reference,\n      domReference,\n      floating\n    },\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: unstable_outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles\n  } = props;\n  const tree = useFloatingTree();\n  const nested = useFloatingParentNodeId() != null;\n  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n  const insideReactTreeRef = React.useRef(false);\n  const {\n    escapeKeyBubbles,\n    outsidePressBubbles\n  } = normalizeBubblesProp(bubbles);\n  const closeOnEscapeKeyDown = useEffectEvent(event => {\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      event.stopPropagation();\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context;\n          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    events.emit('dismiss', {\n      type: 'escapeKey',\n      data: {\n        returnFocus: {\n          preventScroll: false\n        }\n      }\n    });\n    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event);\n  });\n  const closeOnPressOutside = useEffectEvent(event => {\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = insideReactTreeRef.current;\n    insideReactTreeRef.current = false;\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = getTarget(event);\n\n    // Check if the click occurred on the scrollbar\n    if (isHTMLElement(target) && floating) {\n      // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n      // elements.\n      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      if (canScrollY) {\n        const isRTL = getWindow(floating).getComputedStyle(target).direction === 'rtl';\n        if (isRTL) {\n          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n        }\n      }\n      if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n        return;\n      }\n    }\n    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n      var _node$context;\n      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n    });\n    if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        var _child$context2;\n        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n          return;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    events.emit('dismiss', {\n      type: 'outsidePress',\n      data: {\n        returnFocus: nested ? {\n          preventScroll: true\n        } : isVirtualClick(event) || isVirtualPointerEvent(event)\n      }\n    });\n    onOpenChange(false, event);\n  });\n  React.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    function onScroll(event) {\n      onOpenChange(false, event);\n    }\n    const doc = getDocument(floating);\n    escapeKey && doc.addEventListener('keydown', closeOnEscapeKeyDown);\n    outsidePress && doc.addEventListener(outsidePressEvent, closeOnPressOutside);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if (isElement(domReference)) {\n        ancestors = getOverflowAncestors(domReference);\n      }\n      if (isElement(floating)) {\n        ancestors = ancestors.concat(getOverflowAncestors(floating));\n      }\n      if (!isElement(reference) && reference && reference.contextElement) {\n        ancestors = ancestors.concat(getOverflowAncestors(reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', closeOnEscapeKeyDown);\n      outsidePress && doc.removeEventListener(outsidePressEvent, closeOnPressOutside);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, closeOnPressOutside]);\n  React.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onKeyDown: closeOnEscapeKeyDown,\n        [bubbleHandlerKeys[referencePressEvent]]: event => {\n          if (referencePress) {\n            events.emit('dismiss', {\n              type: 'referencePress',\n              data: {\n                returnFocus: false\n              }\n            });\n            onOpenChange(false, event.nativeEvent);\n          }\n        }\n      },\n      floating: {\n        onKeyDown: closeOnEscapeKeyDown,\n        [captureHandlerKeys[outsidePressEvent]]: () => {\n          insideReactTreeRef.current = true;\n        }\n      }\n    };\n  }, [enabled, events, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);\n}\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/react\n */\nfunction useFloating(options) {\n  var _options$elements;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open = false,\n    onOpenChange: unstable_onOpenChange,\n    nodeId\n  } = options;\n  const [_domReference, setDomReference] = React.useState(null);\n  const domReference = ((_options$elements = options.elements) == null ? void 0 : _options$elements.reference) || _domReference;\n  const position = useFloating$1(options);\n  const tree = useFloatingTree();\n  const onOpenChange = useEffectEvent((open, event) => {\n    if (open) {\n      dataRef.current.openEvent = event;\n    }\n    unstable_onOpenChange == null ? void 0 : unstable_onOpenChange(open, event);\n  });\n  const domReferenceRef = React.useRef(null);\n  const dataRef = React.useRef({});\n  const events = React.useState(() => createPubSub())[0];\n  const floatingId = useId();\n  const setPositionReference = React.useCallback(node => {\n    const positionReference = isElement(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    position.refs.setReference(positionReference);\n  }, [position.refs]);\n  const setReference = React.useCallback(node => {\n    if (isElement(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !isElement(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = React.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = React.useMemo(() => ({\n    ...position.elements,\n    domReference: domReference\n  }), [position.elements, domReference]);\n  const context = React.useMemo(() => ({\n    ...position,\n    refs,\n    elements,\n    dataRef,\n    nodeId,\n    floatingId,\n    events,\n    open,\n    onOpenChange\n  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return React.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}\n\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */\nfunction useFocus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    refs,\n    elements: {\n      floating,\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    keyboardOnly = true\n  } = props;\n  const pointerTypeRef = React.useRef('');\n  const blockFocusRef = React.useRef(false);\n  const timeoutRef = React.useRef();\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    const doc = getDocument(floating);\n    const win = doc.defaultView || window;\n\n    // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n    function onBlur() {\n      if (!open && isHTMLElement(domReference) && domReference === activeElement(getDocument(domReference))) {\n        blockFocusRef.current = true;\n      }\n    }\n    win.addEventListener('blur', onBlur);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n    };\n  }, [floating, domReference, open, enabled]);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onDismiss(payload) {\n      if (payload.type === 'referencePress' || payload.type === 'escapeKey') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [events, enabled]);\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(_ref) {\n          let {\n            pointerType\n          } = _ref;\n          pointerTypeRef.current = pointerType;\n          blockFocusRef.current = !!(pointerType && keyboardOnly);\n        },\n        onMouseLeave() {\n          blockFocusRef.current = false;\n        },\n        onFocus(event) {\n          var _dataRef$current$open;\n          if (blockFocusRef.current) {\n            return;\n          }\n\n          // Dismiss with click should ignore the subsequent `focus` trigger,\n          // but only if the click originated inside the reference element.\n          if (event.type === 'focus' && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === 'mousedown' && isEventTargetWithin(dataRef.current.openEvent, domReference)) {\n            return;\n          }\n          onOpenChange(true, event.nativeEvent);\n        },\n        onBlur(event) {\n          blockFocusRef.current = false;\n          const relatedTarget = event.relatedTarget;\n\n          // Hit the non-modal focus management portal guard. Focus will be\n          // moved into the floating element immediately after.\n          const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute('focus-guard')) && relatedTarget.getAttribute('data-type') === 'outside';\n\n          // Wait for the window blur listener to fire.\n          timeoutRef.current = setTimeout(() => {\n            // When focusing the reference element (e.g. regular click), then\n            // clicking into the floating element, prevent it from hiding.\n            // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n            if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {\n              return;\n            }\n            onOpenChange(false, event.nativeEvent);\n          });\n        }\n      }\n    };\n  }, [enabled, keyboardOnly, domReference, refs, dataRef, onOpenChange]);\n}\n\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  return {\n    ...(elementKey === 'floating' && {\n      tabIndex: -1\n    }),\n    ...userProps,\n    ...propsList.map(value => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n          if (typeof value === 'function') {\n            var _map$get;\n            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);\n            acc[key] = function () {\n              var _map$get2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\n\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/react#interaction-hooks\n */\nfunction useInteractions(propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  // The dependencies are a dynamic array, so we can't use the linter's\n  // suggestion to add it to the deps array.\n  const deps = propsList;\n  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getItemProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // Granularly check for `item` changes, because the `getItemProps` getter\n  // should be as referentially stable as possible since it may be passed as\n  // a prop to many components. All `item` key values must therefore be\n  // memoized.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  propsList.map(key => key == null ? void 0 : key.item));\n  return React.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n}\n\nlet isPreventScrollSupported = false;\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  let index = startingIndex;\n  do {\n    var _list$index, _list$index2;\n    index = index + (decrement ? -amount : amount);\n  } while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute('disabled')) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute('aria-disabled')) === 'true'));\n  return index;\n}\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key == ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nfunction useListNavigation(context, props) {\n  const {\n    open,\n    onOpenChange,\n    refs,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1,\n    scrollItemIntoView = true\n  } = props;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));\n      }\n      if (!virtual) {\n        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either \"horizontal\" or \"both\".'].join(' '));\n    }\n  }\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEffectEvent(unstable_onNavigate);\n  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);\n  const indexRef = React.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = React.useRef(null);\n  const isPointerModalityRef = React.useRef(true);\n  const previousOnNavigateRef = React.useRef(onNavigate);\n  const previousMountedRef = React.useRef(!!floating);\n  const forceSyncFocus = React.useRef(false);\n  const forceScrollIntoViewRef = React.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const [activeId, setActiveId] = React.useState();\n  const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {\n    if (forceScrollIntoView === void 0) {\n      forceScrollIntoView = false;\n    }\n    const item = listRef.current[indexRef.current];\n    if (!item) return;\n    if (virtual) {\n      setActiveId(item.id);\n    } else {\n      enqueueFocus(item, {\n        preventScroll: true,\n        // Mac Safari does not move the virtual cursor unless the focus call\n        // is sync. However, for the very first focus call, we need to wait\n        // for the position to be ready in order to prevent unwanted\n        // scrolling. This means the virtual cursor will not move to the first\n        // item when first opening the floating element, but will on\n        // subsequent calls. `preventScroll` is supported in modern Safari,\n        // so we can use that instead.\n        // iOS Safari must be async or the first item will not be focused.\n        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n      });\n    }\n    requestAnimationFrame(() => {\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        item.scrollIntoView == null ? void 0 : item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n    });\n  }, []);\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        onNavigate(selectedIndex);\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n        if (selectedIndex != null) {\n          return;\n        }\n\n        // Reset while the floating element was open (e.g. the list changed).\n        if (previousMountedRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        }\n\n        // Initial sync.\n        if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          let runs = 0;\n          const waitForListPopulated = () => {\n            if (listRef.current[0] == null) {\n              // Avoid letting the browser paint if possible on the first try,\n              // otherwise use rAF. Don't try more than twice, since something\n              // is wrong otherwise.\n              if (runs < 2) {\n                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                scheduler(waitForListPopulated);\n              }\n              runs++;\n            } else {\n              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n              keyRef.current = null;\n              onNavigate(indexRef.current);\n            }\n          };\n          waitForListPopulated();\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n        forceScrollIntoViewRef.current = false;\n      }\n    }\n  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (previousMountedRef.current && !floating && tree) {\n      var _nodes$find, _nodes$find$context;\n      const nodes = tree.nodesRef.current;\n      const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null ? void 0 : (_nodes$find$context = _nodes$find.context) == null ? void 0 : _nodes$find$context.elements.floating;\n      const activeEl = activeElement(getDocument(floating));\n      const treeContainsActiveEl = nodes.some(node => node.context && contains(node.context.elements.floating, activeEl));\n      if (parent && !treeContainsActiveEl) {\n        parent.focus({\n          preventScroll: true\n        });\n      }\n    }\n  }, [enabled, floating, tree, parentId]);\n  index(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousMountedRef.current = !!floating;\n  });\n  index(() => {\n    if (!open) {\n      keyRef.current = null;\n    }\n  }, [open]);\n  const hasActiveIndex = activeIndex != null;\n  const item = React.useMemo(() => {\n    function syncCurrentTarget(currentTarget) {\n      if (!open) return;\n      const index = listRef.current.indexOf(currentTarget);\n      if (index !== -1) {\n        onNavigate(index);\n      }\n    }\n    const props = {\n      onFocus(_ref) {\n        let {\n          currentTarget\n        } = _ref;\n        syncCurrentTarget(currentTarget);\n      },\n      onClick: _ref2 => {\n        let {\n          currentTarget\n        } = _ref2;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      },\n      // Safari\n      ...(focusItemOnHover && {\n        onMouseMove(_ref3) {\n          let {\n            currentTarget\n          } = _ref3;\n          syncCurrentTarget(currentTarget);\n        },\n        onPointerLeave(_ref4) {\n          let {\n            pointerType\n          } = _ref4;\n          if (!isPointerModalityRef.current || pointerType === 'touch') {\n            return;\n          }\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n          onNavigate(null);\n          if (!virtual) {\n            enqueueFocus(refs.floating.current, {\n              preventScroll: true\n            });\n          }\n        }\n      })\n    };\n    return props;\n  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    const disabledIndices = disabledIndicesRef.current;\n    function onKeyDown(event) {\n      isPointerModalityRef.current = false;\n      forceSyncFocus.current = true;\n\n      // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n        return;\n      }\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        stopEvent(event);\n        onOpenChange(false, event.nativeEvent);\n        if (isHTMLElement(domReference)) {\n          domReference.focus();\n        }\n        return;\n      }\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n      if (event.key === 'Home') {\n        stopEvent(event);\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n      if (event.key === 'End') {\n        stopEvent(event);\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      }\n\n      // Grid navigation.\n      if (cols > 1) {\n        const prevIndex = indexRef.current;\n        if (event.key === ARROW_UP) {\n          stopEvent(event);\n          if (prevIndex === -1) {\n            indexRef.current = maxIndex;\n          } else {\n            indexRef.current = findNonDisabledIndex(listRef, {\n              startingIndex: prevIndex,\n              amount: cols,\n              decrement: true,\n              disabledIndices\n            });\n            if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {\n              const col = prevIndex % cols;\n              const maxCol = maxIndex % cols;\n              const offset = maxIndex - (maxCol - col);\n              if (maxCol === col) {\n                indexRef.current = maxIndex;\n              } else {\n                indexRef.current = maxCol > col ? offset : offset - cols;\n              }\n            }\n          }\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            indexRef.current = prevIndex;\n          }\n          onNavigate(indexRef.current);\n        }\n        if (event.key === ARROW_DOWN) {\n          stopEvent(event);\n          if (prevIndex === -1) {\n            indexRef.current = minIndex;\n          } else {\n            indexRef.current = findNonDisabledIndex(listRef, {\n              startingIndex: prevIndex,\n              amount: cols,\n              disabledIndices\n            });\n            if (loop && prevIndex + cols > maxIndex) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex % cols - cols,\n                amount: cols,\n                disabledIndices\n              });\n            }\n          }\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            indexRef.current = prevIndex;\n          }\n          onNavigate(indexRef.current);\n        }\n\n        // Remains on the same row/column.\n        if (orientation === 'both') {\n          const prevRow = Math.floor(prevIndex / cols);\n          if (event.key === ARROW_RIGHT) {\n            stopEvent(event);\n            if (prevIndex % cols !== cols - 1) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                disabledIndices\n              });\n              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex - prevIndex % cols - 1,\n                  disabledIndices\n                });\n              }\n            } else if (loop) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex - prevIndex % cols - 1,\n                disabledIndices\n              });\n            }\n            if (isDifferentRow(indexRef.current, cols, prevRow)) {\n              indexRef.current = prevIndex;\n            }\n          }\n          if (event.key === ARROW_LEFT) {\n            stopEvent(event);\n            if (prevIndex % cols !== 0) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                disabledIndices,\n                decrement: true\n              });\n              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex + (cols - prevIndex % cols),\n                  decrement: true,\n                  disabledIndices\n                });\n              }\n            } else if (loop) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex + (cols - prevIndex % cols),\n                decrement: true,\n                disabledIndices\n              });\n            }\n            if (isDifferentRow(indexRef.current, cols, prevRow)) {\n              indexRef.current = prevIndex;\n            }\n          }\n          const lastRow = Math.floor(maxIndex / cols) === prevRow;\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            if (loop && lastRow) {\n              indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex - prevIndex % cols - 1,\n                disabledIndices\n              });\n            } else {\n              indexRef.current = prevIndex;\n            }\n          }\n          onNavigate(indexRef.current);\n          return;\n        }\n      }\n      if (isMainOrientationKey(event.key, orientation)) {\n        stopEvent(event);\n\n        // Reset the index if no item is focused.\n        if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    }\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n      'aria-activedescendant': activeId\n    };\n    return {\n      reference: {\n        ...ariaActiveDescendantProp,\n        onKeyDown(event) {\n          isPointerModalityRef.current = false;\n          const isArrowKey = event.key.indexOf('Arrow') === 0;\n          if (virtual && open) {\n            return onKeyDown(event);\n          }\n\n          // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n          const isNavigationKey = isArrowKey || event.key === 'Enter' || event.key.trim() === '';\n          const isMainKey = isMainOrientationKey(event.key, orientation);\n          const isCrossKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n          if (isNavigationKey) {\n            keyRef.current = nested && isMainKey ? null : event.key;\n          }\n          if (nested) {\n            if (isCrossKey) {\n              stopEvent(event);\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndices);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true, event.nativeEvent);\n              }\n            }\n            return;\n          }\n          if (isMainKey) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n            stopEvent(event);\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true, event.nativeEvent);\n            } else {\n              onKeyDown(event);\n            }\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n        onFocus() {\n          if (open) {\n            onNavigate(null);\n          }\n        },\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      },\n      floating: {\n        'aria-orientation': orientation === 'both' ? undefined : orientation,\n        ...ariaActiveDescendantProp,\n        onKeyDown,\n        onPointerMove() {\n          isPointerModalityRef.current = true;\n        }\n      },\n      item\n    };\n  }, [domReference, refs, activeId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item]);\n}\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/useMergeRefs\n */\nfunction useMergeRefs(refs) {\n  return React.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          ref.current = value;\n        }\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nfunction useRole(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    floatingId\n  } = context;\n  const {\n    enabled = true,\n    role = 'dialog'\n  } = props;\n  const referenceId = useId();\n  return React.useMemo(() => {\n    const floatingProps = {\n      id: floatingId,\n      role\n    };\n    if (!enabled) {\n      return {};\n    }\n    if (role === 'tooltip') {\n      return {\n        reference: {\n          'aria-describedby': open ? floatingId : undefined\n        },\n        floating: floatingProps\n      };\n    }\n    return {\n      reference: {\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': role === 'alertdialog' ? 'dialog' : role,\n        'aria-controls': open ? floatingId : undefined,\n        ...(role === 'listbox' && {\n          role: 'combobox'\n        }),\n        ...(role === 'menu' && {\n          id: referenceId\n        })\n      },\n      floating: {\n        ...floatingProps,\n        ...(role === 'menu' && {\n          'aria-labelledby': referenceId\n        })\n      }\n    };\n  }, [enabled, role, open, floatingId, referenceId]);\n}\n\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n  return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n  const [isMounted, setIsMounted] = React.useState(open);\n  if (open && !isMounted) {\n    setIsMounted(true);\n  }\n  React.useEffect(() => {\n    if (!open) {\n      const timeout = setTimeout(() => setIsMounted(false), durationMs);\n      return () => clearTimeout(timeout);\n    }\n  }, [open, durationMs]);\n  return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */\nfunction useTransitionStatus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    duration = 250\n  } = props;\n  const isNumberDuration = typeof duration === 'number';\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [initiated, setInitiated] = React.useState(false);\n  const [status, setStatus] = React.useState('unmounted');\n  const isMounted = useDelayUnmount(open, closeDuration);\n\n  // `initiated` check prevents this `setState` call from breaking\n  // <FloatingPortal />. This call is necessary to ensure subsequent opens\n  // after the initial one allows the correct side animation to play when the\n  // placement has changed.\n  index(() => {\n    if (initiated && !isMounted) {\n      setStatus('unmounted');\n    }\n  }, [initiated, isMounted]);\n  index(() => {\n    if (!floating) return;\n    if (open) {\n      setStatus('initial');\n      const frame = requestAnimationFrame(() => {\n        setStatus('open');\n      });\n      return () => {\n        cancelAnimationFrame(frame);\n      };\n    } else {\n      setInitiated(true);\n      setStatus('close');\n    }\n  }, [open, floating]);\n  return {\n    isMounted,\n    status\n  };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */\nfunction useTransitionStyles(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    initial: unstable_initial = {\n      opacity: 0\n    },\n    open: unstable_open,\n    close: unstable_close,\n    common: unstable_common,\n    duration = 250\n  } = props;\n  const placement = context.placement;\n  const side = placement.split('-')[0];\n  const fnArgs = React.useMemo(() => ({\n    side,\n    placement\n  }), [side, placement]);\n  const isNumberDuration = typeof duration === 'number';\n  const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [styles, setStyles] = React.useState(() => ({\n    ...execWithArgsOrReturn(unstable_common, fnArgs),\n    ...execWithArgsOrReturn(unstable_initial, fnArgs)\n  }));\n  const {\n    isMounted,\n    status\n  } = useTransitionStatus(context, {\n    duration\n  });\n  const initialRef = useLatestRef(unstable_initial);\n  const openRef = useLatestRef(unstable_open);\n  const closeRef = useLatestRef(unstable_close);\n  const commonRef = useLatestRef(unstable_common);\n  index(() => {\n    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n      acc[key] = '';\n      return acc;\n    }, {});\n    if (status === 'initial') {\n      setStyles(styles => ({\n        transitionProperty: styles.transitionProperty,\n        ...commonStyles,\n        ...initialStyles\n      }));\n    }\n    if (status === 'open') {\n      setStyles({\n        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: openDuration + \"ms\",\n        ...commonStyles,\n        ...openStyles\n      });\n    }\n    if (status === 'close') {\n      const styles = closeStyles || initialStyles;\n      setStyles({\n        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: closeDuration + \"ms\",\n        ...commonStyles,\n        ...styles\n      });\n    }\n  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n  return {\n    isMounted,\n    styles\n  };\n}\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nfunction useTypeahead(context, props) {\n  var _ref;\n  const {\n    open,\n    dataRef\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch,\n    onTypingChange: unstable_onTypingChange,\n    enabled = true,\n    findMatch = null,\n    resetMs = 750,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = props;\n  const timeoutIdRef = React.useRef();\n  const stringRef = React.useRef('');\n  const prevIndexRef = React.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n  const matchIndexRef = React.useRef(null);\n  const onMatch = useEffectEvent(unstable_onMatch);\n  const onTypingChange = useEffectEvent(unstable_onTypingChange);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation.\n    if (open && stringRef.current === '') {\n      var _ref2;\n      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setTypingChange(value) {\n      if (value) {\n        if (!dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      } else {\n        if (dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      }\n    }\n    function getMatchingIndex(list, orderedList, string) {\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n      return str ? list.indexOf(str) : -1;\n    }\n    function onKeyDown(event) {\n      const listContent = listRef.current;\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n          setTypingChange(false);\n        } else if (event.key === ' ') {\n          stopEvent(event);\n        }\n      }\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n      // Character key.\n      event.key.length !== 1 ||\n      // Modifier key.\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      }\n      if (open && event.key !== ' ') {\n        stopEvent(event);\n        setTypingChange(true);\n      }\n\n      // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      });\n\n      // Allows the user to cycle through items that start with the same letter\n      // in rapid succession.\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        setTypingChange(false);\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      } else if (event.key !== ' ') {\n        stringRef.current = '';\n        setTypingChange(false);\n      }\n    }\n    return {\n      reference: {\n        onKeyDown\n      },\n      floating: {\n        onKeyDown,\n        onKeyUp(event) {\n          if (event.key === ' ') {\n            setTypingChange(false);\n          }\n        }\n      }\n    };\n  }, [enabled, open, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, onTypingChange]);\n}\n\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return {\n    ...state,\n    rects: {\n      ...state.rects,\n      floating: {\n        ...state.rects.floating,\n        height\n      }\n    }\n  };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */\nconst inner = props => ({\n  name: 'inner',\n  options: props,\n  async fn(state) {\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = props;\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index];\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!state.placement.startsWith('bottom')) {\n        console.warn(['Floating UI: `placement` side must be \"bottom\" when using the', '`inner` middleware.'].join(' '));\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = {\n      ...state,\n      ...(await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))\n    };\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await detectOverflow(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: 'reference'\n    });\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY;\n\n    // There is not enough space, fallback to standard anchored positioning\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        flushSync(() => onFallbackChange(true));\n      } else {\n        flushSync(() => onFallbackChange(false));\n      }\n    }\n    if (overflowRef) {\n      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({\n        ...nextArgs,\n        y: nextY\n      }, el.offsetHeight), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */\nfunction useInnerOffset(context, props) {\n  const {\n    open,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = props;\n  const onChange = useEffectEvent(unstable_onChange);\n  const controlledScrollingRef = React.useRef(false);\n  const prevScrollTopRef = React.useRef(null);\n  const initialOverflowRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        flushSync(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test(getUserAgent())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel);\n\n      // Wait for the position to be ready.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = {\n            ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              flushSync(() => onChange(d => d + scrollDiff));\n            }\n          }\n\n          // [Firefox] Wait for the height change to have been applied.\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n      }\n    };\n  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);\n}\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safePolygon\n */\nfunction safePolygon(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    buffer = 0.5,\n    blockPointerEvents = false,\n    requireIntent = true\n  } = options;\n  let timeoutId;\n  let hasLanded = false;\n  let lastX = null;\n  let lastY = null;\n  let lastCursorTime = performance.now();\n  function getCursorSpeed(x, y) {\n    const currentTime = performance.now();\n    const elapsedTime = currentTime - lastCursorTime;\n    if (lastX === null || lastY === null || elapsedTime === 0) {\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return null;\n    }\n    const deltaX = x - lastX;\n    const deltaY = y - lastY;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    const speed = distance / elapsedTime; // px / ms\n\n    lastX = x;\n    lastY = y;\n    lastCursorTime = currentTime;\n    return speed;\n  }\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      elements,\n      onClose,\n      nodeId,\n      tree\n    } = _ref;\n    return function onMouseMove(event) {\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n      clearTimeout(timeoutId);\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = getTarget(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = contains(elements.floating, target);\n      const isOverReferenceEl = contains(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      const isFloatingWider = rect.width > refRect.width;\n      const isFloatingTaller = rect.height > refRect.height;\n      const left = (isFloatingWider ? refRect : rect).left;\n      const right = (isFloatingWider ? refRect : rect).right;\n      const top = (isFloatingTaller ? refRect : rect).top;\n      const bottom = (isFloatingTaller ? refRect : rect).bottom;\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n        return;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n          break;\n        case 'bottom':\n          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n          break;\n      }\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      if (isPointInPolygon([clientX, clientY], rectPoly)) {\n        return;\n      } else if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isLeave && requireIntent) {\n        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n        const cursorSpeedThreshold = 0.1;\n        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n          return close();\n        }\n      }\n      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n        close();\n      } else if (!hasLanded && requireIntent) {\n        timeoutId = window.setTimeout(close, 40);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n\nexport { FloatingArrow, FloatingDelayGroup, FloatingFocusManager, FloatingList, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useClientPoint, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListItem, useListNavigation, useMergeRefs, useRole, useTransitionStatus, useTransitionStyles, useTypeahead };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","import { rectToClientRect, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { detectOverflow, offset } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, flip, hide, inline, limitShift, platform, shift, size };\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return arrow$1({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      } else if (element) {\n        return arrow$1({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length, i, keys;\n  if (a && b && typeof a == 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = React.useState(null);\n  const [_floating, _setFloating] = React.useState(null);\n  const setReference = React.useCallback(node => {\n    if (node != referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, [_setReference]);\n  const setFloating = React.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, [_setFloating]);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = React.useRef(null);\n  const floatingRef = React.useRef(null);\n  const dataRef = React.useRef(data);\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        isPositioned: true\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      } else {\n        update();\n      }\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = React.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...(getDPR(elements.floating) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\nexport { arrow, useFloating };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import React from 'react';\nimport {\n  Box,\n  BoxProps,\n  createVarsResolver,\n  factory,\n  Factory,\n  rem,\n  StylesApiProps,\n  useProps,\n  useStyles,\n} from '../../../core';\nimport classes from '../Button.module.css';\n\nexport type ButtonGroupStylesNames = 'group';\nexport type ButtonGroupCssVariables = {\n  group: '--button-border-width';\n};\n\nexport interface ButtonGroupProps extends BoxProps, StylesApiProps<ButtonGroupFactory> {\n  /** `Button` components */\n  children?: React.ReactNode;\n\n  /** Orientation of the group, `horizontal` by default */\n  orientation?: 'horizontal' | 'vertical';\n\n  /** `border-width` of the child `Button` components. Numbers are converted to rem. Default value in `1`. */\n  borderWidth?: number | string;\n}\n\nexport type ButtonGroupFactory = Factory<{\n  props: ButtonGroupProps;\n  ref: HTMLDivElement;\n  stylesNames: ButtonGroupStylesNames;\n  vars: ButtonGroupCssVariables;\n}>;\n\nconst defaultProps: Partial<ButtonGroupProps> = {\n  orientation: 'horizontal',\n};\n\nconst varsResolver = createVarsResolver<ButtonGroupFactory>((_, { borderWidth }) => ({\n  group: { '--button-border-width': rem(borderWidth) },\n}));\n\nexport const ButtonGroup = factory<ButtonGroupFactory>((_props, ref) => {\n  const props = useProps('ButtonGroup', defaultProps, _props);\n  const {\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    orientation,\n    vars,\n    borderWidth,\n    variant,\n    ...others\n  } = useProps('ButtonGroup', defaultProps, _props);\n\n  const getStyles = useStyles<ButtonGroupFactory>({\n    name: 'ButtonGroup',\n    props,\n    classes,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver,\n    rootSelector: 'group',\n  });\n\n  return (\n    <Box\n      {...getStyles('group')}\n      ref={ref}\n      variant={variant}\n      mod={{ 'data-orientation': orientation }}\n      role=\"group\"\n      {...others}\n    />\n  );\n});\n\nButtonGroup.classes = classes;\nButtonGroup.displayName = '@mantine/core/ButtonGroup';\n","import React from 'react';\nimport {\n  Box,\n  BoxProps,\n  createVarsResolver,\n  getFontSize,\n  getRadius,\n  getSize,\n  MantineColor,\n  MantineGradient,\n  MantineRadius,\n  MantineSize,\n  polymorphicFactory,\n  PolymorphicFactory,\n  StylesApiProps,\n  useProps,\n  useStyles,\n} from '../../core';\nimport { Loader, LoaderProps } from '../Loader';\nimport { UnstyledButton } from '../UnstyledButton';\nimport { ButtonGroup } from './ButtonGroup/ButtonGroup';\nimport classes from './Button.module.css';\n\nexport type ButtonStylesNames = 'root' | 'inner' | 'loader' | 'section' | 'label';\nexport type ButtonVariant =\n  | 'filled'\n  | 'light'\n  | 'outline'\n  | 'transparent'\n  | 'white'\n  | 'subtle'\n  | 'default'\n  | 'gradient';\n\nexport type ButtonCssVariables = {\n  root:\n    | '--button-justify'\n    | '--button-height'\n    | '--button-padding-x'\n    | '--button-fz'\n    | '--button-radius'\n    | '--button-bg'\n    | '--button-hover'\n    | '--button-hover-color'\n    | '--button-color'\n    | '--button-bd';\n};\n\nexport interface ButtonProps extends BoxProps, StylesApiProps<ButtonFactory> {\n  'data-disabled'?: boolean;\n\n  /** Controls button `height`, `font-size` and horizontal `padding`, `'sm'` by default */\n  size?: MantineSize | `compact-${MantineSize}` | (string & {});\n\n  /** Key of `theme.colors` or any valid CSS color, `theme.primaryColor` by default */\n  color?: MantineColor;\n\n  /** Sets `justify-content` of `inner` element, can be used to change distribution of sections and label, `'center'` by default */\n  justify?: React.CSSProperties['justifyContent'];\n\n  /** Content displayed on the left side of the button label */\n  leftSection?: React.ReactNode;\n\n  /** Content displayed on the right side of the button label */\n  rightSection?: React.ReactNode;\n\n  /** Determines whether button should take 100% width of its parent container, `false` by default */\n  fullWidth?: boolean;\n\n  /** Key of `theme.radius` or any valid CSS value to set `border-radius`, `theme.defaultRadius` by default */\n  radius?: MantineRadius;\n\n  /** Gradient configuration used when `variant=\"gradient\"`, default value is `theme.defaultGradient` */\n  gradient?: MantineGradient;\n\n  /** Indicates disabled state */\n  disabled?: boolean;\n\n  /** Button content */\n  children?: React.ReactNode;\n\n  /** Determines whether the `Loader` component should be displayed over the button */\n  loading?: boolean;\n\n  /** Props added to the `Loader` component (only visible when `loading` prop is set) */\n  loaderProps?: LoaderProps;\n\n  /** Determines whether button text color with filled variant should depend on `background-color`. If luminosity of the `color` prop is less than `theme.luminosityThreshold`, then `theme.white` will be used for text color, otherwise `theme.black`. Overrides `theme.autoContrast`. */\n  autoContrast?: boolean;\n}\n\nexport type ButtonFactory = PolymorphicFactory<{\n  props: ButtonProps;\n  defaultRef: HTMLButtonElement;\n  defaultComponent: 'button';\n  stylesNames: ButtonStylesNames;\n  vars: ButtonCssVariables;\n  variant: ButtonVariant;\n  staticComponents: {\n    Group: typeof ButtonGroup;\n  };\n}>;\n\nconst defaultProps: Partial<ButtonProps> = {};\n\nconst varsResolver = createVarsResolver<ButtonFactory>(\n  (theme, { radius, color, gradient, variant, size, justify, autoContrast }) => {\n    const colors = theme.variantColorResolver({\n      color: color || theme.primaryColor,\n      theme,\n      gradient,\n      variant: variant || 'filled',\n      autoContrast,\n    });\n\n    return {\n      root: {\n        '--button-justify': justify,\n        '--button-height': getSize(size, 'button-height'),\n        '--button-padding-x': getSize(size, 'button-padding-x'),\n        '--button-fz': size?.includes('compact')\n          ? getFontSize(size.replace('compact-', ''))\n          : getFontSize(size),\n        '--button-radius': radius === undefined ? undefined : getRadius(radius),\n        '--button-bg': color || variant ? colors.background : undefined,\n        '--button-hover': color || variant ? colors.hover : undefined,\n        '--button-color': colors.color,\n        '--button-bd': color || variant ? colors.border : undefined,\n        '--button-hover-color': color || variant ? colors.hoverColor : undefined,\n      },\n    };\n  }\n);\n\nexport const Button = polymorphicFactory<ButtonFactory>((_props, ref) => {\n  const props = useProps('Button', defaultProps, _props);\n  const {\n    style,\n    vars,\n    className,\n    color,\n    disabled,\n    children,\n    leftSection,\n    rightSection,\n    fullWidth,\n    variant,\n    radius,\n    loading,\n    loaderProps,\n    gradient,\n    classNames,\n    styles,\n    unstyled,\n    'data-disabled': dataDisabled,\n    autoContrast,\n    ...others\n  } = props;\n\n  const getStyles = useStyles<ButtonFactory>({\n    name: 'Button',\n    props,\n    classes,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver,\n  });\n\n  const hasLeftSection = !!leftSection;\n  const hasRightSection = !!rightSection;\n\n  return (\n    <UnstyledButton\n      ref={ref}\n      {...getStyles('root', { active: !disabled && !loading && !dataDisabled })}\n      unstyled={unstyled}\n      variant={variant}\n      disabled={disabled || loading}\n      mod={{\n        disabled: disabled || dataDisabled,\n        loading,\n        block: fullWidth,\n        'with-left-section': hasLeftSection,\n        'with-right-section': hasRightSection,\n      }}\n      {...others}\n    >\n      <Box component=\"span\" {...getStyles('loader')} aria-hidden>\n        <Loader\n          color=\"var(--button-color)\"\n          size=\"calc(var(--button-height) / 1.8)\"\n          {...loaderProps}\n        />\n      </Box>\n\n      <span {...getStyles('inner')}>\n        {leftSection && (\n          <Box component=\"span\" {...getStyles('section')} mod={{ position: 'left' }}>\n            {leftSection}\n          </Box>\n        )}\n\n        <Box component=\"span\" mod={{ loading }} {...getStyles('label')}>\n          {children}\n        </Box>\n\n        {rightSection && (\n          <Box component=\"span\" {...getStyles('section')} mod={{ position: 'right' }}>\n            {rightSection}\n          </Box>\n        )}\n      </span>\n    </UnstyledButton>\n  );\n});\n\nButton.classes = classes;\nButton.displayName = '@mantine/core/Button';\nButton.Group = ButtonGroup;\n","import { SystemPropData } from '../../core';\n\nexport const FLEX_STYLE_PROPS_DATA: Record<string, SystemPropData> = {\n  gap: { type: 'spacing', property: 'gap' },\n  rowGap: { type: 'spacing', property: 'rowGap' },\n  columnGap: { type: 'spacing', property: 'columnGap' },\n\n  align: { type: 'identity', property: 'alignItems' },\n  justify: { type: 'identity', property: 'justifyContent' },\n  wrap: { type: 'identity', property: 'flexWrap' },\n  direction: { type: 'identity', property: 'flexDirection' },\n};\n","import React from 'react';\nimport {\n  Box,\n  BoxProps,\n  ElementProps,\n  filterProps,\n  InlineStyles,\n  MantineSize,\n  parseStyleProps,\n  polymorphicFactory,\n  PolymorphicFactory,\n  StyleProp,\n  StylesApiProps,\n  useMantineTheme,\n  useProps,\n  useRandomClassName,\n  useStyles,\n} from '../../core';\nimport { FLEX_STYLE_PROPS_DATA } from './flex-props';\nimport classes from './Flex.module.css';\n\nexport type FlexStylesNames = 'root';\n\nexport interface FlexProps extends BoxProps, StylesApiProps<FlexFactory>, ElementProps<'div'> {\n  /** `gap` CSS property */\n  gap?: StyleProp<MantineSize | (string & {}) | number>;\n\n  /** `row-gap` CSS property */\n  rowGap?: StyleProp<MantineSize | (string & {}) | number>;\n\n  /** `column-gap` CSS property */\n  columnGap?: StyleProp<MantineSize | (string & {}) | number>;\n\n  /** `align-items` CSS property */\n  align?: StyleProp<React.CSSProperties['alignItems']>;\n\n  /** `justify-content` CSS property */\n  justify?: StyleProp<React.CSSProperties['justifyContent']>;\n\n  /** `flex-wrap` CSS property */\n  wrap?: StyleProp<React.CSSProperties['flexWrap']>;\n\n  /** `flex-direction` CSS property */\n  direction?: StyleProp<React.CSSProperties['flexDirection']>;\n}\n\nexport type FlexFactory = PolymorphicFactory<{\n  props: FlexProps;\n  defaultRef: HTMLDivElement;\n  defaultComponent: 'div';\n  stylesNames: FlexStylesNames;\n}>;\n\nconst defaultProps: Partial<FlexProps> = {};\n\nexport const Flex = polymorphicFactory<FlexFactory>((_props, ref) => {\n  const props = useProps('Flex', defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    vars,\n    gap,\n    rowGap,\n    columnGap,\n    align,\n    justify,\n    wrap,\n    direction,\n    ...others\n  } = props;\n\n  const getStyles = useStyles<FlexFactory>({\n    name: 'Flex',\n    classes,\n    props,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n  });\n\n  const theme = useMantineTheme();\n  const responsiveClassName = useRandomClassName();\n  const parsedStyleProps = parseStyleProps({\n    styleProps: { gap, rowGap, columnGap, align, justify, wrap, direction },\n    theme,\n    data: FLEX_STYLE_PROPS_DATA,\n  });\n\n  return (\n    <>\n      {parsedStyleProps.hasResponsiveStyles && (\n        <InlineStyles\n          selector={`.${responsiveClassName}`}\n          styles={parsedStyleProps.styles}\n          media={parsedStyleProps.media}\n        />\n      )}\n      <Box\n        ref={ref}\n        {...getStyles('root', {\n          className: responsiveClassName,\n          style: filterProps(parsedStyleProps.inlineStyles),\n        })}\n        {...others}\n      />\n    </>\n  );\n});\n\nFlex.classes = classes;\nFlex.displayName = '@mantine/core/Flex';\n","import { rem } from '../../../core';\nimport type { ArrowPosition, FloatingPlacement, FloatingPosition, FloatingSide } from '../types';\n\nfunction horizontalSide(\n  placement: FloatingPlacement | 'center',\n  arrowY: number | undefined,\n  arrowOffset: number,\n  arrowPosition: ArrowPosition\n) {\n  if (placement === 'center' || arrowPosition === 'center') {\n    return { top: arrowY };\n  }\n\n  if (placement === 'end') {\n    return { bottom: arrowOffset };\n  }\n\n  if (placement === 'start') {\n    return { top: arrowOffset };\n  }\n\n  return {};\n}\n\nfunction verticalSide(\n  placement: FloatingPlacement | 'center',\n  arrowX: number | undefined,\n  arrowOffset: number,\n  arrowPosition: ArrowPosition,\n  dir: 'rtl' | 'ltr'\n) {\n  if (placement === 'center' || arrowPosition === 'center') {\n    return { left: arrowX };\n  }\n\n  if (placement === 'end') {\n    return { [dir === 'ltr' ? 'right' : 'left']: arrowOffset };\n  }\n\n  if (placement === 'start') {\n    return { [dir === 'ltr' ? 'left' : 'right']: arrowOffset };\n  }\n\n  return {};\n}\n\nconst radiusByFloatingSide: Record<\n  FloatingSide,\n  keyof Pick<\n    React.CSSProperties,\n    | 'borderBottomLeftRadius'\n    | 'borderBottomRightRadius'\n    | 'borderTopLeftRadius'\n    | 'borderTopRightRadius'\n  >\n> = {\n  bottom: 'borderTopLeftRadius',\n  left: 'borderTopRightRadius',\n  right: 'borderBottomLeftRadius',\n  top: 'borderBottomRightRadius',\n};\n\nexport function getArrowPositionStyles({\n  position,\n  arrowSize,\n  arrowOffset,\n  arrowRadius,\n  arrowPosition,\n  arrowX,\n  arrowY,\n  dir,\n}: {\n  position: FloatingPosition;\n  arrowSize: number;\n  arrowOffset: number;\n  arrowRadius: number;\n  arrowPosition: ArrowPosition;\n  arrowX: number | undefined;\n  arrowY: number | undefined;\n  dir: 'rtl' | 'ltr';\n}) {\n  const [side, placement = 'center'] = position.split('-') as [FloatingSide, FloatingPlacement];\n  const baseStyles = {\n    width: rem(arrowSize),\n    height: rem(arrowSize),\n    transform: 'rotate(45deg)',\n    position: 'absolute',\n    [radiusByFloatingSide[side]]: rem(arrowRadius),\n  };\n\n  const arrowPlacement = rem(-arrowSize / 2);\n\n  if (side === 'left') {\n    return {\n      ...baseStyles,\n      ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),\n      right: arrowPlacement,\n      borderLeftColor: 'transparent',\n      borderBottomColor: 'transparent',\n    };\n  }\n\n  if (side === 'right') {\n    return {\n      ...baseStyles,\n      ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),\n      left: arrowPlacement,\n      borderRightColor: 'transparent',\n      borderTopColor: 'transparent',\n    };\n  }\n\n  if (side === 'top') {\n    return {\n      ...baseStyles,\n      ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),\n      bottom: arrowPlacement,\n      borderTopColor: 'transparent',\n      borderLeftColor: 'transparent',\n    };\n  }\n\n  if (side === 'bottom') {\n    return {\n      ...baseStyles,\n      ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),\n      top: arrowPlacement,\n      borderBottomColor: 'transparent',\n      borderRightColor: 'transparent',\n    };\n  }\n\n  return {};\n}\n","import React, { forwardRef } from 'react';\nimport { useDirection } from '../../../core';\nimport { ArrowPosition, FloatingPosition } from '../types';\nimport { getArrowPositionStyles } from './get-arrow-position-styles';\n\ninterface FloatingArrowProps extends React.ComponentPropsWithoutRef<'div'> {\n  position: FloatingPosition;\n  arrowSize: number;\n  arrowOffset: number;\n  arrowRadius: number;\n  arrowPosition: ArrowPosition;\n  arrowX: number | undefined;\n  arrowY: number | undefined;\n  visible: boolean | undefined;\n}\n\nexport const FloatingArrow = forwardRef<HTMLDivElement, FloatingArrowProps>(\n  (\n    {\n      position,\n      arrowSize,\n      arrowOffset,\n      arrowRadius,\n      arrowPosition,\n      visible,\n      arrowX,\n      arrowY,\n      style,\n      ...others\n    },\n    ref\n  ) => {\n    const { dir } = useDirection();\n    if (!visible) {\n      return null;\n    }\n\n    return (\n      <div\n        {...others}\n        ref={ref}\n        style={{\n          ...style,\n          ...getArrowPositionStyles({\n            position,\n            arrowSize,\n            arrowOffset,\n            arrowRadius,\n            arrowPosition,\n            dir,\n            arrowX,\n            arrowY,\n          }),\n        }}\n      />\n    );\n  }\n);\n\nFloatingArrow.displayName = '@mantine/core/FloatingArrow';\n","import type { FloatingPlacement, FloatingPosition, FloatingSide } from '../types';\n\nexport function getFloatingPosition(\n  dir: 'rtl' | 'ltr',\n  position: FloatingPosition\n): FloatingPosition {\n  if (dir === 'rtl' && (position.includes('right') || position.includes('left'))) {\n    const [side, placement] = position.split('-') as [FloatingSide, FloatingPlacement];\n    const flippedPosition = side === 'right' ? 'left' : 'right';\n    return placement === undefined ? flippedPosition : `${flippedPosition}-${placement}`;\n  }\n\n  return position;\n}\n","import { useEffect, useState } from 'react';\nimport { autoUpdate } from '@floating-ui/react';\nimport { useDidUpdate } from '@mantine/hooks';\nimport { FloatingPosition } from './types';\n\ninterface Payload {\n  opened: boolean | undefined;\n  floating: {\n    update: () => void;\n    refs: {\n      floating: React.MutableRefObject<any>;\n      reference: React.MutableRefObject<any>;\n    };\n  };\n  positionDependencies: any[];\n  position: FloatingPosition;\n}\n\nexport function useFloatingAutoUpdate({\n  opened,\n  floating,\n  position,\n  positionDependencies,\n}: Payload) {\n  const [delayedUpdate, setDelayedUpdate] = useState(0);\n\n  useEffect(() => {\n    if (floating.refs.reference.current && floating.refs.floating.current) {\n      return autoUpdate(\n        floating.refs.reference.current,\n        floating.refs.floating.current,\n        floating.update\n      );\n    }\n\n    return undefined;\n  }, [\n    floating.refs.reference.current,\n    floating.refs.floating.current,\n    opened,\n    delayedUpdate,\n    position,\n  ]);\n\n  useDidUpdate(() => {\n    floating.update();\n  }, positionDependencies);\n\n  useDidUpdate(() => {\n    setDelayedUpdate((c) => c + 1);\n  }, [opened]);\n}\n","import React, { forwardRef, useRef, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport { assignRef, useIsomorphicEffect } from '@mantine/hooks';\nimport { useProps } from '../../core';\n\nfunction createPortalNode(props: React.ComponentPropsWithoutRef<'div'>) {\n  const node = document.createElement('div');\n  node.setAttribute('data-portal', 'true');\n  typeof props.className === 'string' &&\n    node.classList.add(...props.className.split(' ').filter(Boolean));\n  typeof props.style === 'object' && Object.assign(node.style, props.style);\n  typeof props.id === 'string' && node.setAttribute('id', props.id);\n  return node;\n}\n\nexport interface PortalProps extends React.ComponentPropsWithoutRef<'div'> {\n  /** Portal children, for example, custom modal or popover */\n  children: React.ReactNode;\n\n  /** Element inside which portal should be created, by default a new div element is created and appended to the `document.body` */\n  target?: HTMLElement | string;\n}\n\nconst defaultProps: Partial<PortalProps> = {};\n\nexport const Portal = forwardRef<HTMLDivElement, PortalProps>((props, ref) => {\n  const { children, target, ...others } = useProps('Portal', defaultProps, props);\n\n  const [mounted, setMounted] = useState(false);\n  const nodeRef = useRef<HTMLElement | null>(null);\n\n  useIsomorphicEffect(() => {\n    setMounted(true);\n    nodeRef.current = !target\n      ? createPortalNode(others)\n      : typeof target === 'string'\n        ? document.querySelector(target)\n        : target;\n\n    assignRef(ref, nodeRef.current);\n\n    if (!target && nodeRef.current) {\n      document.body.appendChild(nodeRef.current);\n    }\n\n    return () => {\n      if (!target && nodeRef.current) {\n        document.body.removeChild(nodeRef.current);\n      }\n    };\n  }, [target]);\n\n  if (!mounted || !nodeRef.current) {\n    return null;\n  }\n\n  return createPortal(<>{children}</>, nodeRef.current);\n});\n\nPortal.displayName = '@mantine/core/Portal';\n","import React from 'react';\nimport { Portal, PortalProps } from './Portal';\n\nexport interface OptionalPortalProps extends PortalProps {\n  /** Determines whether children should be rendered inside `<Portal />` */\n  withinPortal?: boolean;\n}\n\nexport function OptionalPortal({ withinPortal = true, children, ...others }: OptionalPortalProps) {\n  if (withinPortal) {\n    return <Portal {...others}>{children}</Portal>;\n  }\n\n  return <>{children}</>;\n}\n\nOptionalPortal.displayName = '@mantine/core/OptionalPortal';\n","import React from 'react';\nimport {\n  Box,\n  BoxProps,\n  createVarsResolver,\n  ElementProps,\n  factory,\n  Factory,\n  getSpacing,\n  MantineSpacing,\n  StylesApiProps,\n  useProps,\n  useStyles,\n} from '../../core';\nimport classes from './Stack.module.css';\n\nexport type StackStylesNames = 'root';\nexport type StackCssVariables = {\n  root: '--stack-gap' | '--stack-align' | '--stack-justify';\n};\n\nexport interface StackProps extends BoxProps, StylesApiProps<StackFactory>, ElementProps<'div'> {\n  /** Key of `theme.spacing` or any valid CSS value to set `gap` property, numbers are converted to rem, `'md'` by default */\n  gap?: MantineSpacing;\n\n  /** Controls `align-items` CSS property, `'stretch'` by default */\n  align?: React.CSSProperties['alignItems'];\n\n  /** Controls `justify-content` CSS property, `'flex-start'` by default */\n  justify?: React.CSSProperties['justifyContent'];\n}\n\nexport type StackFactory = Factory<{\n  props: StackProps;\n  ref: HTMLDivElement;\n  stylesNames: StackStylesNames;\n  vars: StackCssVariables;\n}>;\n\nconst defaultProps: Partial<StackProps> = {\n  gap: 'md',\n  align: 'stretch',\n  justify: 'flex-start',\n};\n\nconst varsResolver = createVarsResolver<StackFactory>((_, { gap, align, justify }) => ({\n  root: {\n    '--stack-gap': getSpacing(gap),\n    '--stack-align': align,\n    '--stack-justify': justify,\n  },\n}));\n\nexport const Stack = factory<StackFactory>((_props, ref) => {\n  const props = useProps('Stack', defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    vars,\n    align,\n    justify,\n    gap,\n    variant,\n    ...others\n  } = props;\n\n  const getStyles = useStyles<StackFactory>({\n    name: 'Stack',\n    props,\n    classes,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver,\n  });\n\n  return <Box ref={ref} {...getStyles('root')} variant={variant} {...others} />;\n});\n\nStack.classes = classes;\nStack.displayName = '@mantine/core/Stack';\n","import React from 'react';\nimport {\n  Box,\n  BoxMod,\n  BoxProps,\n  createVarsResolver,\n  getFontSize,\n  getGradient,\n  getLineHeight,\n  getThemeColor,\n  MantineColor,\n  MantineGradient,\n  MantineSize,\n  polymorphicFactory,\n  PolymorphicFactory,\n  StylesApiProps,\n  useProps,\n  useStyles,\n} from '../../core';\nimport classes from './Text.module.css';\n\ntype TextTruncate = 'end' | 'start' | boolean;\n\nfunction getTextTruncate(truncate: TextTruncate | undefined) {\n  if (truncate === 'start') {\n    return 'start';\n  }\n\n  if (truncate === 'end' || truncate) {\n    return 'end';\n  }\n\n  return undefined;\n}\n\nexport type TextStylesNames = 'root';\nexport type TextVariant = 'text' | 'gradient';\nexport type TextCssVariables = {\n  root: '--text-gradient' | '--text-line-clamp' | '--text-fz' | '--text-lh';\n};\n\nexport interface TextProps extends BoxProps, StylesApiProps<TextFactory> {\n  __staticSelector?: string;\n  mod?: BoxMod;\n\n  /** Controls `font-size` and `line-height`, `'md'` by default */\n  size?: MantineSize | (string & {});\n\n  /** Number of lines after which Text will be truncated */\n  lineClamp?: number;\n\n  /** Side on which Text must be truncated, if `true`, text is truncated from the start */\n  truncate?: TextTruncate;\n\n  /** Sets `line-height` to 1 for centering, `false` by default */\n  inline?: boolean;\n\n  /** Determines whether font properties should be inherited from the parent, `false` by default */\n  inherit?: boolean;\n\n  /** Gradient configuration, ignored when `variant` is not `gradient`, `theme.defaultGradient` by default */\n  gradient?: MantineGradient;\n\n  /** Shorthand for `component=\"span\"`, `false` by default, default root element is `p` */\n  span?: boolean;\n\n  /** @deprecated Use `c` prop instead */\n  color?: MantineColor;\n}\n\nexport type TextFactory = PolymorphicFactory<{\n  props: TextProps;\n  defaultComponent: 'p';\n  defaultRef: HTMLParagraphElement;\n  stylesNames: TextStylesNames;\n  vars: TextCssVariables;\n  variant: TextVariant;\n}>;\n\nconst defaultProps: Partial<TextProps> = {\n  inherit: false,\n};\n\nconst varsResolver = createVarsResolver<TextFactory>(\n  (theme, { variant, lineClamp, gradient, size, color }) => ({\n    root: {\n      '--text-fz': getFontSize(size),\n      '--text-lh': getLineHeight(size),\n      '--text-gradient': variant === 'gradient' ? getGradient(gradient, theme) : undefined,\n      '--text-line-clamp': typeof lineClamp === 'number' ? lineClamp.toString() : undefined,\n      '--text-color': color ? getThemeColor(color, theme) : undefined,\n    },\n  })\n);\n\nexport const Text = polymorphicFactory<TextFactory>((_props, ref) => {\n  const props = useProps('Text', defaultProps, _props);\n  const {\n    lineClamp,\n    truncate,\n    inline,\n    inherit,\n    gradient,\n    span,\n    __staticSelector,\n    vars,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    variant,\n    mod,\n    size,\n    ...others\n  } = props;\n\n  const getStyles = useStyles<TextFactory>({\n    name: ['Text', __staticSelector],\n    props,\n    classes,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver,\n  });\n\n  return (\n    <Box\n      {...getStyles('root', { focusable: true })}\n      ref={ref}\n      component={span ? 'span' : 'p'}\n      variant={variant}\n      mod={[\n        {\n          'data-truncate': getTextTruncate(truncate),\n          'data-line-clamp': typeof lineClamp === 'number',\n          'data-inline': inline,\n          'data-inherit': inherit,\n        },\n        mod,\n      ]}\n      size={size}\n      {...others}\n    />\n  );\n});\n\nText.classes = classes;\nText.displayName = '@mantine/core/Text';\n","import React from 'react';\nimport {\n  Box,\n  BoxComponentProps,\n  polymorphicFactory,\n  PolymorphicFactory,\n  StylesApiProps,\n  useProps,\n  useStyles,\n} from '../../core';\nimport classes from './UnstyledButton.module.css';\n\nexport type UnstyledButtonStylesNames = 'root';\n\nexport interface UnstyledButtonProps\n  extends Omit<BoxComponentProps, 'vars' | 'variant'>,\n    StylesApiProps<UnstyledButtonFactory> {\n  __staticSelector?: string;\n}\n\nconst defaultProps: Partial<UnstyledButtonProps> = {\n  __staticSelector: 'UnstyledButton',\n};\n\nexport type UnstyledButtonFactory = PolymorphicFactory<{\n  props: UnstyledButtonProps;\n  stylesNames: UnstyledButtonStylesNames;\n  defaultComponent: 'button';\n  defaultRef: HTMLButtonElement;\n}>;\n\nexport const UnstyledButton = polymorphicFactory<UnstyledButtonFactory>(\n  (_props: UnstyledButtonProps & { component?: any }, ref) => {\n    const props = useProps('UnstyledButton', defaultProps, _props);\n    const {\n      className,\n      component = 'button',\n      __staticSelector,\n      unstyled,\n      classNames,\n      styles,\n      style,\n      ...others\n    } = props;\n\n    const getStyles = useStyles<UnstyledButtonFactory>({\n      name: __staticSelector!,\n      props,\n      classes,\n      className,\n      style,\n      classNames,\n      styles,\n      unstyled,\n    });\n\n    return (\n      <Box\n        {...getStyles('root', { focusable: true })}\n        component={component}\n        ref={ref}\n        type={component === 'button' ? 'button' : undefined}\n        {...others}\n      />\n    );\n  }\n);\n\nUnstyledButton.classes = classes;\nUnstyledButton.displayName = '@mantine/core/UnstyledButton';\n","import React, { createContext, useContext, useState } from 'react';\nimport { useIsomorphicEffect } from '@mantine/hooks';\n\nexport type Direction = 'ltr' | 'rtl';\n\nexport interface DirectionContextValue {\n  dir: Direction;\n  toggleDirection: () => void;\n  setDirection: (dir: Direction) => void;\n}\n\nexport const DirectionContext = createContext<DirectionContextValue>({\n  dir: 'ltr',\n  toggleDirection: () => {},\n  setDirection: () => {},\n});\n\nexport function useDirection() {\n  return useContext(DirectionContext);\n}\n\nexport interface DirectionProviderProps {\n  /** Your application */\n  children: React.ReactNode;\n\n  /** Direction set as a default value, `ltr` by default */\n  initialDirection?: Direction;\n\n  /** Determines whether direction should be updated on mount based on `dir` attribute set on root element (usually html element), `true` by default  */\n  detectDirection?: boolean;\n}\n\nexport function DirectionProvider({\n  children,\n  initialDirection = 'ltr',\n  detectDirection = true,\n}: DirectionProviderProps) {\n  const [dir, setDir] = useState<Direction>(initialDirection);\n\n  const setDirection = (direction: Direction) => {\n    setDir(direction);\n    document.documentElement.setAttribute('dir', direction);\n  };\n\n  const toggleDirection = () => setDirection(dir === 'ltr' ? 'rtl' : 'ltr');\n\n  useIsomorphicEffect(() => {\n    if (detectDirection) {\n      const direction = document.documentElement.getAttribute('dir');\n      if (direction === 'rtl' || direction === 'ltr') {\n        setDirection(direction);\n      }\n    }\n  }, []);\n\n  return (\n    <DirectionContext.Provider value={{ dir, toggleDirection, setDirection }}>\n      {children}\n    </DirectionContext.Provider>\n  );\n}\n","import React from 'react';\n\nexport function isElement(value: any): value is React.ReactElement {\n  if (Array.isArray(value) || value === null) {\n    return false;\n  }\n\n  if (typeof value === 'object') {\n    if (value.type === React.Fragment) {\n      return false;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import React from 'react';\n\nconst __useId: () => string | undefined = (React as any)['useId'.toString()] || (() => undefined);\n\nexport function useReactId() {\n  const id = __useId();\n  return id ? `mantine-${id.replace(/:/g, '')}` : '';\n}\n","import { useState } from 'react';\nimport { useIsomorphicEffect } from '../use-isomorphic-effect/use-isomorphic-effect';\nimport { randomId } from '../utils';\nimport { useReactId } from './use-react-id';\n\nexport function useId(staticId?: string) {\n  const reactId = useReactId();\n  const [uuid, setUuid] = useState(reactId);\n\n  useIsomorphicEffect(() => {\n    setUuid(randomId());\n  }, []);\n\n  if (typeof staticId === 'string') {\n    return staticId;\n  }\n\n  if (typeof window === 'undefined') {\n    return reactId;\n  }\n\n  return uuid;\n}\n","import { Ref, useCallback } from 'react';\n\ntype PossibleRef<T> = Ref<T> | undefined;\n\nexport function assignRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (typeof ref === 'object' && ref !== null && 'current' in ref) {\n    (ref as React.MutableRefObject<T>).current = value;\n  }\n}\n\nexport function mergeRefs<T>(...refs: PossibleRef<T>[]) {\n  return (node: T | null) => {\n    refs.forEach((ref) => assignRef(ref, node));\n  };\n}\n\nexport function useMergedRef<T>(...refs: PossibleRef<T>[]) {\n  return useCallback(mergeRefs(...refs), refs);\n}\n","export function randomId() {\n  return `mantine-${Math.random().toString(36).slice(2, 11)}`;\n}\n"],"names":["index","document","useLayoutEffect","useEffect","serverHandoffComplete","count","genId","useId","React","toString","id","setId","undefined","createPubSub","map","Map","emit","event","data","_map$get","get","forEach","handler","on","listener","set","off","_map$get2","filter","l","FloatingNodeContext","FloatingTreeContext","useFloatingParentNodeId","_React$useContext","useFloatingTree","getDocument","node","ownerDocument","getPlatform","uaData","navigator","userAgentData","platform","getUserAgent","Array","isArray","brands","_ref","brand","version","join","userAgent","getWindow","value","defaultView","window","isElement","Element","isHTMLElement","HTMLElement","isVirtualClick","mozInputSource","isTrusted","androidRe","test","pointerType","type","buttons","detail","isVirtualPointerEvent","width","height","pressure","isMouseLikePointerType","strict","values","push","includes","contains","parent","child","rootNode","getRootNode","ShadowRoot","next","parentNode","host","createAttribute","name","useLatestRef","ref","useRef","current","safePolygonIdentifier","getDelay","prop","useHover","context","props","open","onOpenChange","dataRef","events","elements","domReference","floating","refs","enabled","delay","handleClose","mouseOnly","restMs","move","tree","parentId","handleCloseRef","delayRef","pointerTypeRef","timeoutRef","handlerRef","restTimeoutRef","blockMouseMoveRef","performedPointerEventsMutationRef","unbindMouseMoveRef","isHoverOpen","_dataRef$current$open","openEvent","onDismiss","clearTimeout","onLeave","html","documentElement","addEventListener","removeEventListener","closeWithDelay","runElseBranch","closeDelay","setTimeout","cleanupMouseMoveHandler","clearPointerEvents","body","style","pointerEvents","removeAttribute","onScrollMouseLeave","onMouseEnter","once","onMouseLeave","isClickLikeOpenEvent","openDelay","doc","x","clientX","y","clientY","onClose","relatedTarget","_handleCloseRef$curre","__options","blockPointerEvents","setAttribute","_tree$nodesRef$curren","_tree$nodesRef$curren2","parentFloating","nodesRef","find","setPointerRef","reference","onPointerDown","onPointerEnter","onMouseMove","nativeEvent","returnFocus","FloatingDelayGroupContext","initialDelay","timeoutMs","currentId","setCurrentId","setState","isInstantPhase","useDelayGroupContext","FloatingDelayGroup","children","state","prev","initialCurrentIdRef","Provider","useDelayGroup","_ref2","_ref3","close","unset","timeout","activeElement","_activeElement","_activeElement$shadow","shadowRoot","getChildren","nodes","allChildren","_node$context","currentChildren","length","_currentChildren","some","n","_node$context2","concat","getTarget","composedPath","target","useSafeInsertionEffect","fn","useEffectEvent","callback","process","_len","arguments","args","_key","isEventTargetWithin","e","bubbleHandlerKeys","pointerdown","mousedown","click","captureHandlerKeys","normalizeBubblesProp","bubbles","_bubbles$escapeKey","_bubbles$outsidePress","escapeKeyBubbles","escapeKey","outsidePressBubbles","outsidePress","useDismiss","nodeId","unstable_outsidePress","outsidePressEvent","referencePress","referencePressEvent","ancestorScroll","nested","outsidePressFn","insideReactTreeRef","closeOnEscapeKeyDown","key","stopPropagation","shouldDismiss","_child$context","__escapeKeyBubbles","preventScroll","isReactEvent","closeOnPressOutside","insideReactTree","canScrollX","clientWidth","scrollWidth","canScrollY","clientHeight","scrollHeight","xCond","offsetX","getComputedStyle","direction","offsetWidth","offsetY","targetIsInsideChildren","_child$context2","__outsidePressBubbles","onScroll","ancestors","getOverflowAncestors","contextElement","ancestor","_doc$defaultView","visualViewport","passive","onKeyDown","useFloating","options","_options$elements","unstable_onOpenChange","_domReference","setDomReference","position","useFloating$1","domReferenceRef","floatingId","setPositionReference","positionReference","getBoundingClientRect","setReference","useFocus","keyboardOnly","blockFocusRef","win","onBlur","payload","onFocus","movedToFocusGuard","hasAttribute","getAttribute","mergeProps","userProps","propsList","elementKey","tabIndex","reduce","acc","Object","entries","indexOf","has","val","useInteractions","deps","getReferenceProps","getFloatingProps","getItemProps","item","useRole","role","referenceId","floatingProps","computeCoordsFromPlacement","placement","rtl","sideAxis","getSideAxis","alignmentAxis","getAlignmentAxis","alignLength","getAxisLength","side","getSide","isVertical","commonX","commonY","commonAlign","coords","getAlignment","computePosition","async","config","strategy","middleware","validMiddleware","Boolean","isRTL","rects","getElementRects","statefulPlacement","middlewareData","resetCount","i","nextX","nextY","reset","initialPlacement","detectOverflow","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","padding","evaluate","paddingObject","getPaddingObject","element","clippingClientRect","rectToClientRect","getClippingRect","getDocumentElement","rect","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","top","bottom","left","right","arrow","axis","arrowDimensions","getDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","min","maxPadding","min$1","max","center","offset","clamp","shouldAddOffset","alignmentOffset","centerOffset","flip","_middlewareData$arrow","_middlewareData$flip","mainAxis","checkMainAxis","crossAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","detectOverflowOptions","isBasePlacement","getOppositePlacement","getExpandedPlacements","getOppositeAxisPlacements","placements","overflow","overflows","overflowsData","sides","getAlignmentSides","every","_middlewareData$flip2","_overflowsData$filter","nextIndex","nextPlacement","resetPlacement","d","sort","a","b","_overflowsData$map$so","getBoundingRect","minX","minY","inline","nativeClientRects","from","getClientRects","clientRects","sortedRects","slice","groups","prevRect","getRectsByLine","fallback","resetRects","firstRect","lastRect","isTop","isLeftSide","maxRight","minLeft","measureRects","_middlewareData$offse","diffCoords","alignment","mainAxisMulti","crossAxisMulti","rawValue","convertValueToCoords","shift","limiter","getOppositeAxis","mainAxisCoord","crossAxisCoord","maxSide","limitedCoords","limitShift","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse2","isOriginSide","size","apply","heightSide","widthSide","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","maximumClippingWidth","maximumClippingHeight","xMin","xMax","yMin","yMax","nextDimensions","getCssDimensions","css","parseFloat","hasOffset","offsetHeight","shouldFallback","round","$","unwrapElement","domElement","createCoords","Number","isFinite","noOffsets","getVisualOffsets","isWebKit","offsetLeft","offsetTop","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","isFixed","floatingOffsetParent","shouldAddVisualOffsets","offsetWin","currentIFrame","frameElement","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","getWindowScrollBarX","getNodeScroll","scrollLeft","getClientRectFromClippingAncestor","clippingAncestor","visualViewportBased","getViewportRect","scroll","scrollTop","getDocumentRect","getInnerBoundingClientRect","hasFixedPositionAncestor","stopNode","getParentNode","isLastTraversableNode","getRectRelativeToOffsetParent","isOffsetParentAnElement","offsets","getNodeName","isOverflowElement","offsetRect","getTrueOffsetParent","polyfill","isTableElement","isContainingBlock","getContainingBlock","clippingAncestors","cache","cachedResult","result","el","currentContainingBlockComputedStyle","elementIsFixed","currentNode","computedStyle","currentNodeIsContaining","getClippingElementAncestors","this","_c","firstClippingAncestor","clippingRect","accRect","getOffsetParentFn","getDimensionsFn","autoUpdate","update","ancestorResize","elementResize","ResizeObserver","layoutShift","IntersectionObserver","animationFrame","referenceEl","cleanupIo","onMove","timeoutId","io","root","cleanup","disconnect","refresh","skip","threshold","rootMargin","floor","isFirstUpdate","handleObserve","ratio","intersectionRatio","observe","observeMove","frameId","reobserveFrame","resizeObserver","firstEntry","unobserve","cancelAnimationFrame","requestAnimationFrame","prevRefRect","frameLoop","nextRefRect","shift$1","flip$1","size$1","arrow$1","inline$1","limitShift$1","mergedOptions","platformWithCache","computePosition$1","hasOwnProperty","call","deepEqual","keys","$$typeof","getDPR","devicePixelRatio","roundByDPR","dpr","Math","externalReference","externalFloating","transform","whileElementsMounted","setData","isPositioned","latestMiddleware","setLatestMiddleware","_reference","_setReference","_floating","_setFloating","referenceRef","setFloating","floatingRef","floatingEl","whileElementsMountedRef","platformRef","then","fullData","isMountedRef","ReactDOM","floatingStyles","initialStyles","willChange","isNode","nodeName","toLowerCase","_node$ownerDocument","Node","isShadowRoot","overflowX","overflowY","display","webkit","perspective","containerType","backdropFilter","contain","CSS","supports","pageXOffset","pageYOffset","assignedSlot","getNearestOverflowAncestor","list","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","v","oppositeSideMap","oppositeAlignmentMap","start","end","param","split","mainAlignmentSide","oppositePlacement","getOppositeAlignmentPlacement","replace","isStart","lr","rl","tb","bt","getSideList","expandPaddingObject","defaultProps","orientation","varsResolver","createVarsResolver","_","borderWidth","group","rem","ButtonGroup","factory","_props","useProps","className","classNames","styles","unstyled","vars","variant","others","getStyles","useStyles","classes","rootSelector","Box","mod","displayName","theme","radius","color","gradient","justify","autoContrast","colors","variantColorResolver","primaryColor","getSize","getFontSize","getRadius","background","hover","border","hoverColor","Button","polymorphicFactory","disabled","leftSection","rightSection","fullWidth","loading","loaderProps","dataDisabled","hasLeftSection","hasRightSection","UnstyledButton","active","block","component","Loader","Group","FLEX_STYLE_PROPS_DATA","gap","property","rowGap","columnGap","align","wrap","Flex","useMantineTheme","responsiveClassName","useRandomClassName","parsedStyleProps","parseStyleProps","styleProps","hasResponsiveStyles","InlineStyles","selector","media","filterProps","inlineStyles","horizontalSide","arrowY","arrowOffset","arrowPosition","verticalSide","arrowX","dir","radiusByFloatingSide","getArrowPositionStyles","arrowSize","arrowRadius","baseStyles","arrowPlacement","borderLeftColor","borderBottomColor","borderRightColor","borderTopColor","FloatingArrow","forwardRef","visible","useDirection","getFloatingPosition","flippedPosition","useFloatingAutoUpdate","opened","positionDependencies","delayedUpdate","setDelayedUpdate","useState","useDidUpdate","c","Portal","mounted","setMounted","nodeRef","useIsomorphicEffect","querySelector","createElement","classList","add","assign","createPortalNode","assignRef","appendChild","removeChild","createPortal","OptionalPortal","withinPortal","getSpacing","Stack","getTextTruncate","truncate","inherit","lineClamp","getLineHeight","getGradient","getThemeColor","Text","span","__staticSelector","focusable","DirectionContext","createContext","toggleDirection","setDirection","useContext","__useId","staticId","reactId","useReactId","uuid","setUuid","randomId","useMergedRef","_len2","_key2","useCallback","mergeRefs","random"],"sourceRoot":""}